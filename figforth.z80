	.TITLE	Z80 fig-FORTH 1.1 g
;	SUBTTL	Adaptive version by EHR
;
;
; Modified frm FIG document keyed by Dennis L. Wilson 800907
; Converted frm "8080 FIG-FORTH VERSION A0 15SEP79"
;
; fig-FORTH release 1.1 for the 8080 processor.
;
; ALL PUBLICATIONS OF THE FORTH INTEREST GROUP
; ARE PUBLIC DOMAIN. THEY MAY BE FURTHER
; DISTRIBUTED BY THE INCLUSION OF THIS CREDIT NOTICE:
;
; This publication has been made available by the
;	Forth Interest Group
;	P.O.Box 1105
;	San Carlos, CA 94070
;	U.S.A.
;
; Implementation on 8080 by:
;	John Cassady
;	339 15th Street
;	Oakland, CA 94612
;	U.S.A
;	on 790528
; Modified by:
;	Kim Harris
; Acknowledgements:
;	George Flammer
;	Robt. D. Villwock
; ----------------------------------------------------------------------
; Z80 Version for Cromemco CDOS & Digital Research CP/M by:
;	Dennis Lee Wilson c/o
;	Aristotelian Logicians
;	2631 East Pinchot Avenue
;	Phoenix, AZ 85016
;	U.S.A.
; ----------------------------------------------------------------------
; The 2 byte Z80 code for Jump Relative (JR) has been substituted for
; the 3 byte Jump (JP) wherever practical. The port I/O words P@ & P!
; have been made ROMable by use of Z80 instructions.
; ----------------------------------------------------------------------
; Further modifications (marked ;/) by:
;	Edmund Ramm
;	Anderheitsallee 24
;	2000 Hamburg 71
;	Fed. Rep. of Germany	840418
; ----------------------------------------------------------------------
; Disc I/O has been modified a la Albert van der Horst (HCCH) to employ
; CP/M 2.x's random access feature.
; ----------------------------------------------------------------------
;
;	Release & Version numbers
;
FIGREL	.EQU	1		;FIG RELEASE #
FIGREV	.EQU	1		;FIG REVISION #
USRVER	.EQU	67H		;USER VERSION # g by DLW/EHR/AvdH
;
;Console & printer drivers are in external source named
;CONPRTIO.FTH & disc drivers in DISCIO.FTH. It has 4 screen
;buffers & end of memory is set to FBASE from locn. 0007H.
	.EJECT
;	ASCII characters used
;
ABL	.EQU	20H		;BLANK
ACR	.EQU	0DH		;CR
ADOT	.EQU	2EH		;.
BELL	.EQU	07H		;^G
BSIN	.EQU	08H		;backspace chr = ^H
BSOUT	.EQU	08H
DLE	.EQU	10H		;^P
LF	.EQU	0AH		;^J
FF	.EQU	0CH		;^L
;
;	Memory allocation
;
BDOSS	.EQU	0005H		;/ system entry
NSCR	.EQU	4		;  # of 1024 byte screens
KBBUF	.EQU	128		;  bytes/disc buffer
US	.EQU	40H		;  user variables space
RTS	.EQU	400H		;  Return Stack & term buff space
CO	.EQU	KBBUF+4		;  Disc buff + 2 header + 2 tail
NBUF	.EQU	NSCR*400H/KBBUF	;  # of buffers
BUFSIZ	.EQU	CO*NBUF		;/ total disc buffer size
	.EJECT
	;ABS
;
	.ORG	0100H
ORIG:	NOP
	JP	CLD		;VECTOR TO COLD START
	NOP
	JP	WRM		;VECTOR TO WARM START
	.BYTE	FIGREL		;FIG RELEASE #
	.BYTE	FIGREV		;FIG REVISION #
	.BYTE	USRVER		;USER VERSION #
	.BYTE	0EH		;IMPLEMENTATION ATTRIBUTES
;
;
;
;	0EH = 0000:1110
;	      ---------
; B +ORIGIN   ...W:IEBA
;
; W: 0=above sufficient
;    1=other differences exist
; I: Interpreter is	0=pre-
;			1=post incrementing
; E: Addr must be even: 0 yes
;			1 no
; B: High byte @	0=low addr.
;			1=high addr.
; A: CPU Addr.		0=BYTE
;			1=WORD
;
;
;
	.WORD	TASK-7		;  TOPMOST WORD IN FORTH VOCABULARY
	.WORD	BSIN		;  BACKSPACE CHR
UPINIT:	.WORD	0		;/ INIT (UP)
;
; * FOLLOWING USED BY COLD; MUST BE IN SAME ORDER AS USER VARIABLES *
;
S0INIT:	.WORD	0		;/ INIT (S0)
R0INIT:	.WORD	0		;/ INIT (R0)
TIBINI:	.WORD	0		;/ INIT (TIB)
	.WORD	1FH		;  INIT (WIDTH)
	.WORD	0		;  INIT (WARNING)
	.WORD	INITDP		;  INIT (FENCE)
	.WORD	INITDP		;  INIT (DP)
	.WORD	FORTH+8		;  INIT (VOC-LINK)
;
; *  END DATA USED BY COLD *
;
	.WORD	0H,0B250H	;Z80 CPU NAME (HW,LW)
				;(32 BIT BASE 36 INTEGER)
	.EJECT
;	REGISTERS
;
;	FORTH	Z80	FORTH PRESERVATION RULES
;	-----	---	-----------------------
;	IP	BC	should be preserved
;			accross FORTH words.
;	W	DE	sometimes output from
;			NEXT, may be altered
;			b4 JP'ing to NEXT,
;			input only when 
;			"DPUSH" called.
;	SP	SP	should be used only as
;			Data Stack accross
;			FORTH words, may be
;			used within FORTH
;			words if restored
;			b4 "NEXT"
;		HL	Never output frm NEXT
;			input only when
;			"HPUSH" called
;
;
UP:	.WORD	0		;/ USER AREA PTR
RPP:	.WORD	0		;/ RETURN STACK PTR
BUF1:	.WORD	0		;/ address of 1st disc buffer
;
;
;	COMMENT CONVENTIONS:
;
;	=	MEANS "IS EQUAL TO"
;	<--	MEANS ASSIGNMENT
;	NAME	=     ADDR OF NAME
;	(NAME)  =     CONTENTS @ NAME
;	((NAME))=     INDIRECT CONTENTS
;	CFA	=     CODE FIELD ADDR
;	LFA	=     LINK FIELD ADDR
;	NFA	=     NAME FIELD ADDR
;	PFA	=     PARAMETER FIELD ADDR
;	S1	=     ADDR OF 1st WORD OF PARAMETER STACK
;	S2	=     -"-  OF 2nd -"-  OF    -"-     -"-
;	R1	=     -"-  OF 1st -"-  OF RETURN STACK
;	R2	=     -"-  OF 2nd -"-  OF  -"-    -"-
; ( above Stack posn. valid b4 & after execution of any word, not during)
;
;	LSB	=     LEAST SIGNIFICANT BIT
;	MSB	=     MOST  SIGNIFICANT BIT
;	LB	=     LOW  BYTE
;	HB	=     HIGH BYTE
;	LW	=     LOW  WORD
;	HW	=     HIGH WORD
; (May be used as suffix to above names)
	.EJECT
;	FORTH ADDRESS INTERPRETER
;	POST INCREMENTING VERSION
;
DPUSH:	PUSH	DE
HPUSH:	PUSH	HL		;		IY points here
NEXT:	LD	A,(BC)		;(W)<--((IP))	IX points here
	LD	L,A
	INC	BC		;INC IP
	LD	A,(BC)
	LD	H,A		;(HL)<--CFA
	INC	BC		;INC IP
NEXT1:	LD	E,(HL)		;(PC)<--((W))
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	JP	(HL)		;NOTE: (DE)=CFA+1
;
;
#DEFINE	JNEXT	JP	(IX)
;
;
#DEFINE JHPUSH	JP	(IY)
;
;
	.EJECT
;	FORTH DICTIONARY
;	DICTIONARY FORMAT:
;
;				BYTE
;	ADDRESS NAME		CONTENTS
;	------- ----		--------
;						(MSB=1
;						(P=PRECEDENCE BIT
;						(S=SMUDGE BIT
;	NFA	NAME FIELD	1PS<LEN>	<NAME LENGTH
;				0<1CHAR>	MSB=0, NAME'S 1st CHAR
;				0<2CHAR>
;				  ...
;				1<LCHAR>	MSB=1, NAME'S LAST CHAR
;	LFA	LINK FIELD	<LINKLB>	=PREVIOUS WORD'S NFA
;				<LINKHB>
;LABEL:	CFA	CODE FIELD	<CODELB>	=ADDR CPU CODE
;				<CODEHB>
;	PFA	PARAMETER	<1PARAM>	1st PARAMETER BYTE
;		FIELD		<2PARAM>
;				  ...
;
;
;
DP0:	.BYTE	83H		;LIT
	.TEXT	"LI"
	.BYTE	'T'+$80
	.WORD	0		;(LFA)=0 MARKS END OF DICTIONARY
LIT:	.WORD	$+2		;(S1)<--((IP))
	LD	A,(BC)		;(HL)<--((IP))=LITERAL
	INC	BC		;(IP)<--(IP)+2
	LD	L,A		;LB
	LD	A,(BC)		;HB
	INC	BC
	LD	H,A
	JHPUSH			;(S1)<--(HL)
;
	.BYTE	87H		;EXECUTE
	.TEXT	"EXECUT"
	.BYTE	'E'+$80
	.WORD	LIT-6
EXEC:	.WORD	$+2
	POP	HL
	JP	NEXT1
;
	.BYTE	86H		;BRANCH
	.TEXT	"BRANC"
	.BYTE	'H'+$80
	.WORD	EXEC-0AH
BRAN:	.WORD	$+2		;(IP)<--(IP)+((IP))
BRAN1:	LD	H,B		;(HL)<--(IP)
	LD	L,C
	LD	E,(HL)		;(DE)<--((IP))=BRANCH OFFSET
	INC	HL
	LD	D,(HL)
	DEC	HL
	ADD	HL,DE		;(HL)<--(HL)+((IP))
	LD	C,L		;(IP)<--(HL)
	LD	B,H
	JNEXT
;
	.BYTE	87H		;0BRANCH
	.TEXT	"0BRANC"
	.BYTE	'H'+$80
	.WORD	BRAN-9
ZBRAN:	.WORD	$+2
	POP	HL
	LD	A,L
	OR	H
	JR	Z,BRAN1		;IF (S1)=0 THEN BRANCH
	INC	BC		;ELSE SKIP BRANCH OFFSET
	INC	BC
	JNEXT
;
	.BYTE	86H		;(LOOP)
	.TEXT	"(LOOP"
	.BYTE	')'+$80
	.WORD	ZBRAN-0AH
XLOOP:	.WORD	$+2
	LD	HL,(RPP)	;  ((HL))=INDEX=(R1)
	inc	(hl)		;/  index(lb) += 1
	LD	E,(HL)		;/
	INC	HL		;/ (hl)-->index(hb)
	jr	nz,xloop1	;/ jump if ((hl)) < 256
	inc	(hl)		;/ else index(hb) += 1
xloop1:	LD	D,(HL)		;/ (DE)<-- new INDEX
	INC	HL		;/ ((HL))=LIMIT
	LD	A,E
	SUB	(HL)
	LD	A,D
	INC	HL
	SBC	A,(HL)		;  INDEX<LIMIT?
	JP	M,BRAN1		;  YES, LOOP AGAIN
	INC	HL		;  NO, DONE
	LD	(RPP),HL	;  DISCARD R1 & R2
	INC	BC
	INC	BC		;  SKIP BRANCH OFFSET
	JNEXT
;
	.BYTE	87H		;(+LOOP)
	.TEXT	"(+LOOP"
	.BYTE	')'+$80
	.WORD	XLOOP-9
XPLOO:	.WORD	$+2
	POP	DE		;(DE)<--INCR
	LD	HL,(RPP)	;((HL))=INDEX
	LD	A,(HL)		;INDEX<--INDEX+INCR
	ADD	A,E
	LD	(HL),A
	LD	E,A
	INC	HL
	LD	A,(HL)
	ADC	A,D
	LD	(HL),A
	INC	HL		;((HL))=LIMIT
	INC	D
	DEC	D
	LD	D,A		;(DE)<--NEW INDEX
	JP	M,XLOO2		;IF INCR>0
	LD	A,E
	SUB	(HL)		;THEN (A)<--INDEX - LIMIT
	LD	A,D
	INC	HL
	SBC	A,(HL)
	JP	XLOO3
XLOO2:	LD	A,(HL)		;ELSE (A)<--LIMIT - INDEX
	SUB	E
	INC	HL
	LD	A,(HL)
	SBC	A,D
;				;IF (A)<0
XLOO3:	JP	M,BRAN1		;THEN LOOP AGN
	INC	HL		;ELSE DONE
	LD	(RPP),HL	;DISCARD R1 & R2
	INC	BC		;SKIP BRANCH OFFSET
	INC	BC
	JNEXT
;
	.BYTE	84H		;  (DO)
	.TEXT	"(DO"
	.BYTE	')'+$80
	.WORD	XPLOO-0AH
XDO:	.WORD	$+2
	EXX			;/ SAVE IP
	POP	DE		;  (DE)<--INITIAL INDEX
	POP	BC		;/ (BC)<--LIMIT
	LD	HL,(RPP)	;  (HL)<--(RP)
	DEC	HL
	LD	(HL),B
	DEC	HL
	LD	(HL),C		;/ (R2)<--LIMIT
	DEC	HL
	LD	(HL),D
	DEC	HL
	LD	(HL),E		;  (R1)<--INITIAL INDEX
	LD	(RPP),HL	;  (RP)<--(RP)-4
	EXX			;/ RESTORE IP
	JNEXT
;
	.BYTE	81H		;I
	.BYTE	'I'+$80
	.WORD	XDO-7
IDO:	.WORD	$+2		;(S1)<--(R1), (R1) UNCHANGED
	LD	HL,(RPP)
	LD	E,(HL)		;(DE)<--(R1)
	INC	HL
	LD	D,(HL)
	PUSH	DE		;(S1)<--(DE)
	JNEXT
;
	.BYTE	85H		;DIGIT
	.TEXT	"DIGI"
	.BYTE	'T'+$80
	.WORD	IDO-4
DIGIT:	.WORD	$+2
	POP	HL		;(L)<--(S1)LB = BASE VALUE
	POP	DE		;(E)<--(S2)LB = ASCII CHR TO BE CONVERTED
	LD	A,E		;ACCU<--CHR
	SUB	'0'		;>=0?
	JR	C,DIGI2		;/ <0 IS INVALID
	CP	0AH		;>9?
	JR	C,DIGI1		;/ NO, TEST BASE VALUE
	SUB	07H		;GAP BETWEEN "9" & "A", NW "A"=0AH
	CP	0AH		;>="A"?
	JR	C,DIGI2		;/ CHRs BETWEEN "9" & "A" ARE INVALID
DIGI1:	CP	L		;<BASE VALUE?
	JR	NC,DIGI2	;/ NO, INVALID
	LD	E,A		;(S2)<--(DE) = CONVERTED DIGIT
	LD	HL,0001H	;(S1)<--TRUE
	JP	DPUSH
DIGI2:	LD	L,H		;(HL)<--FALSE
	JHPUSH			;(S1)<--FALSE
;
	.BYTE	86H		;(FIND) (2-1)FAILURE
	.TEXT	"(FIND"	;	(2-3)SUCCESS
	.BYTE	')'+$80
	.WORD	DIGIT-8
PFIND:	.WORD	$+2
	POP	DE		;(DE)<--NFA
PFIN1:	POP	HL		;(HL)<--STRING ADDR
	PUSH	HL		;SAVE FOR NEXT ITERATION
	LD	A,(DE)
	XOR	(HL)		;FILTER DEVIATIONS
	AND	3FH		;MASK MSB & PRECEDENCE BIT
	JR	NZ,PFIN4	;LENGTHS DIFFER
PFIN2:	INC	HL		;(HL)<--ADDR NEXT CHR IN STRING
	INC	DE		;(DE)<--ADDR NEXT CHR IN NF
	LD	A,(DE)
	XOR	(HL)		;FILTER DEVIATIONS
	ADD	A,A
	JR	NZ,PFIN3	;NO MATCH
	JR	NC,PFIN2	;MATCH SO FAR, LOOP AGN
	LD	HL,0005H	;STRING MATCHES
	ADD	HL,DE		;((SP))<--PFA
	EX	(SP),HL
PFIN6:	DEC	DE		;POSN DE ON NFA
	LD	A,(DE)
	OR	A		;MSB=1? =LENGTH BYTE
	JP	P,PFIN6		;NO, TRY NEXT CHR
	LD	E,A		;(E)<--LENGTH BYTE
	LD	D,00H
	LD	HL,0001H	;(HL)<--TRUE
	JP	DPUSH		;NF FOUND, RETURN
;
;ABOVE NF NOT A MATCH, TRY NEXT ONE
;
PFIN3:	JR	C,PFIN5		;CARRY=END OF NF
PFIN4:	INC	DE		;FIND END OF NF
	LD	A,(DE)
	OR	A		;MSB=1?
	JP	P,PFIN4		;NO, LOOP
PFIN5:	INC	DE		;(DE)<--LFA
	EX	DE,HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		;(DE)<--(LFA)
	LD	A,D
	OR	E		;END OF DICTIONARY? (LFA)=0
	JR	NZ,PFIN1	;NO, TRY PREVIOUS DEFINITION
	POP	HL		;DROP STRING ADDR
	LD	HL,0		;(HL)<--FALSE
	JHPUSH			;NO MATCH FOUND, RETURN
;
	.BYTE	87H		;ENCLOSE
	.TEXT	"ENCLOS"
	.BYTE	'E'+$80
	.WORD	PFIND-9
ENCL:	.WORD	$+2
	POP	DE		;(DE)<--(S1)=DELIMITER CHR
	POP	HL		;(HL)<--(S2)=ADDR OF TEXT TO SCAN
	PUSH	HL		;(S4)<--ADDR
	LD	A,E
	LD	D,A		;(D)<--DELIM CHR
	LD	E,-1		;INIT CHR OFFSET COUNTER
	DEC	HL		;(HL)<--ADDR-1
ENCL1:	INC	HL		;SKIP OVER LEADING DELIM CHRs
	INC	E
	CP	(HL)		;DELIM CHR?
	JR	Z,ENCL1		;YES, LOOP
	LD	D,0
	PUSH	DE		;(S3)<--(E)=OFFSET TO 1st NON DELIM
	LD	D,A		;(D)<--DELIM CHR
	LD	A,(HL)
	AND	A		;1st non-DELIM=NULL?
	JR	NZ,ENCL2	;NO
	LD	D,0		;YES
	INC	E
	PUSH	DE		;(S2)<--OFFSET TO BYTE FOLLOWING NULL
	DEC	E
	PUSH	DE		;(S1)<--OFFSET TO NULL
	JNEXT
ENCL2:	LD	A,D		;(A)<--DELIM CHR
	INC	HL		;(HL)<--ADDR NEXT CHR
	INC	E		;(E)<--OFFSET TO NEXT CHR
	CP	(HL)		;DELIM CHR?
	JR	Z,ENCL4		;YES
	LD	A,(HL)
	AND	A		;NULL?
	JR	NZ,ENCL2	;NO, CONT SCAN
ENCL3:	LD	D,0
	PUSH	DE		;(S2)<--OFFSET TO NULL
	PUSH	DE		;(S1)<--OFFSET TO NULL
	JNEXT
ENCL4:	LD	D,0
	PUSH	DE		;(S2)<--OFFSET TO BYTE FOLLOWING TEXT
	INC	E
	PUSH	DE		;(S1)<--OFFSET TO 2 BYTES AFTER END OF WORD
	JNEXT
;
	.BYTE	84H		;EMIT
	.TEXT	"EMI"
	.BYTE	'T'+$80
	.WORD	ENCL-0AH
EMIT:	.WORD	DOCOL
	.WORD	PEMIT
	.WORD	ONE,OUTT
	.WORD	PSTOR,SEMIS
;
	.BYTE	83H		;KEY
	.TEXT	"KE"
	.BYTE	'Y'+$80
	.WORD	EMIT-7
KEY:	.WORD	$+2
	JP	PKEY
;
	.BYTE	89H		;?TERMINAL
	.TEXT	"?TERMINA"
	.BYTE	'L'+$80
	.WORD	KEY-6
QTERM:	.WORD	$+2
	LD	HL,0
	JP	PQTER
;
	.BYTE	82H		;CR
	.BYTE	'C'
	.BYTE	'R'+$80
	.WORD	QTERM-0CH
CR:	.WORD	$+2
	JP	PCR
;
	.BYTE	85H		;CMOVE
	.TEXT	"CMOV"
	.BYTE	'E'+$80
	.WORD	CR-5
CMOVE:	.WORD	$+2
	EXX			;/ SAVE IP
	POP	BC		;  (BC)<--(S1)= #CHRs
	POP	DE		;  (DE)<--(S2)= DEST ADDR
	POP	HL		;/ (HL)<--(S3)= SOURCE ADDR
	LD	A,B
	OR	C		;  BC=0?
	JR	Z,EXCMOV	;  YES, DON'T MOVE ANYTHING
	LDIR			;/ XFER STRING
EXCMOV:	EXX			;/ RESTORE IP
	JNEXT
;
	.BYTE	82H		;U*   16*16 unsigned multiply
	.BYTE	'U'		;994 T cycles average (8080)
	.BYTE	'*'+$80
	.WORD	CMOVE-8
USTAR:	.WORD	$+2
	POP	DE		;(DE)<--MPLIER
	POP	HL		;(HL)<--MPCAND
	PUSH	BC		;SAVE IP
	LD	B,H
	LD	A,L		;(BA)<--MPCAND
	CALL	MPYX		;(AHL)1<--MPCAND.LB*MPLIER
				;       1st PARTIAL PRODUCT
	PUSH	HL		;SAVE (HL)1
	LD	H,A
	LD	A,B
	LD	B,H		;SAVE (A)1
	CALL	MPYX		;(AHL)2<--MPCAND.HB*MPLIER
				;	2nd PARTIAL PRODUCT
	POP	DE		;(DE)<--(HL)1
	LD	C,D		;(BC)<--(AH)1
;	FORM SUM OF PARTIALS:
;				; (AHL)1
;				;+(AHL)2
;				;-------
;				; (AHLE)
	ADD	HL,BC		;(HL)<--(HL)2+(AH)1
	ADC	A,00H		;(AHLE)<--(BA)*(DE)
	LD	D,L
	LD	L,H
	LD	H,A		;(HLDE)<--MPLIER*MPCAND
	POP	BC		;RESTORE IP
	PUSH	DE		;(S2)<--PRODUCT.LW
	JHPUSH			;(S1)<--PRODUCT.HW
;
;	MULTIPLY PRIMITIVE
;		 (AHL)<--(A)*(DE)
;	#BITS:	  24	8   16
;
MPYX:	LD	HL,0		;(HL)<--0=PARTIAL PRODUCT.LW
	LD	C,08H		;LOOP COUNTER
MPYX1:	ADD	HL,HL		;LEFT SHIFT (AHL) 24 BITS
	RLA
	JR	NC,MPYX2	;IF NEXT MPLIER BIT = 1
	ADD	HL,DE		;THEN ADD MPCAND
	ADC	A,0
MPYX2:	DEC	C		;LAST MPLIER BIT?
	JR	NZ,MPYX1	;NO, LOOP AGN
	RET			;YES, DONE
;
	.BYTE	82H		;U/
	.BYTE	'U'
	.BYTE	'/'+$80
	.WORD	USTAR-5
USLAS:	.WORD	$+2
	LD	HL,0004H
	ADD	HL,SP		;((HL))<--NUMERATOR.LW
	LD	E,(HL)		;(DE)<--NUMER.LW
	LD	(HL),C		;SAVE IP ON STACK
	INC	HL
	LD	D,(HL)
	LD	(HL),B
	POP	BC		;(BC)<--DENOMINATOR
	POP	HL		;(HL)<--NUMER.HW
	LD	A,L
	SUB	C
	LD	A,H
	SBC	A,B		;NUMER >= DENOM?
	JR	C,USLA1		;NO, GO AHEAD
	LD	HL,0FFFFH	;YES, OVERFLOW
	LD	D,H
	LD	E,L		;/ SET REM & QUOT TO MAX
	JP	USLA7
USLA1:	LD	A,10H		;LOOP COUNTER
USLA2:	ADD	HL,HL		;LEFT SHIFT (HLDE) THRU CARRY
	RLA			;ROT CARRY INTO ACCU BIT 0
	EX	DE,HL
	ADD	HL,HL
	JR	NC,USLA3
	INC	DE		;ADD CARRY
	AND	A		;RESET CARRY
USLA3:	EX	DE,HL		;SHIFT DONE
	RRA			;RESTORE 1st CARRY & COUNTER
	JR	NC,USLA4	;IF CARRY=1
	OR	A		;/ RESET CARRY
	SBC	HL,BC		;/ THEN (HL)<--(HL)-(BC)
	JP	USLA5
USLA4:	SBC	HL,BC		;/ (HL)<--PARTIAL REMAINDER
	JR	NC,USLA5
	ADD	HL,BC		;UNDERFLOW, RESTORE
	DEC	DE
USLA5:	INC	DE		;INC QUOT
	DEC	A		;COUNTER=0?
	JP	NZ,USLA2	;NO, LOOP AGN
USLA7:	POP	BC		;RESTORE IP
	PUSH	HL		;(S2)<--REMAINDER
	PUSH	DE		;(S1)<--QUOTIENT
	JNEXT
;
	.BYTE	83H		;AND
	.TEXT	"AN"
	.BYTE	'D'+$80
	.WORD	USLAS-5
ANDD:	.WORD	$+2		;(S1)<--(S1) AND (S2)
	POP	DE
	POP	HL
	LD	A,E
	AND	L
	LD	L,A
	LD	A,D
	AND	H
	LD	H,A
	JHPUSH
;
	.BYTE	82H		;OR
	.BYTE	'O'
	.BYTE	'R'+$80
	.WORD	ANDD-6
ORR:	.WORD	$+2		;(S1)<--(S1) OR (S2)
	POP	DE
	POP	HL
	LD	A,E
	OR	L
	LD	L,A
	LD	A,D
	OR	H
	LD	H,A
	JHPUSH
;
	.BYTE	83H		;XOR
	.TEXT	"XO"
	.BYTE	'R'+$80
	.WORD	ORR-5
XORR:	.WORD	$+2		;(S1)<--(S1) XOR (S2)
	POP	DE
	POP	HL
	LD	A,E
	XOR	L
	LD	L,A
	LD	A,D
	XOR	H
	LD	H,A
	JHPUSH
;
	.BYTE	83H		;SP@
	.TEXT	"SP"
	.BYTE	'@'+$80
	.WORD	XORR-6
SPAT:	.WORD	$+2		;(S1)<--(SP)
	LD	HL,0
	ADD	HL,SP		;(HL)<--(SP)
	JHPUSH
;
	.BYTE	83H		;SP!
	.TEXT	"SP"
	.BYTE	'!'+$80
	.WORD	SPAT-6
SPSTO:	.WORD	$+2		;(SP)<--(S0) (USER VARIABLE)
	LD	HL,(UP)		;(HL)<--USER VAR BASE ADDR
	LD	DE,0006H
	ADD	HL,DE		;(HL)<--S0
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		;(DE)<--(S0)
	EX	DE,HL
	LD	SP,HL		;(SP)<--(S0)
	JNEXT
;
	.BYTE	83H		;RP@
	.TEXT	"RP"
	.BYTE	'@'+$80
	.WORD	SPSTO-6
RPAT:	.WORD	$+2		;(S1)<--(RP)
	LD	HL,(RPP)
	JHPUSH
;
	.BYTE	83H		;RP!
	.TEXT	"RP"
	.BYTE	'!'+$80
	.WORD	RPAT-6
RPSTO:	.WORD	$+2		;(RP)<--(R0) (USER VARIABLE)
	LD	HL,(UP)		;(HL)<--USER VAR BASE ADDR
	LD	DE,0008H
	ADD	HL,DE		;(HL)<--R0
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		;(DE)<--(R0)
	LD	(RPP),DE	;/ (RP)<--(R0)
	JNEXT
;
	.BYTE	82H		; ;S
	.BYTE	';'
	.BYTE	'S'+$80
	.WORD	RPSTO-6
SEMIS:	.WORD	$+2		;(IP)<--(R1)
	LD	HL,(RPP)
	LD	C,(HL)
	INC	HL
	LD	B,(HL)		;(BC)<--(R1)
	INC	HL
	LD	(RPP),HL	;(RP)<--(RP)+2
	JNEXT
;
	.BYTE	85H		;LEAVE
	.TEXT	"LEAV"
	.BYTE	'E'+$80
	.WORD	SEMIS-5
LEAVE:	.WORD	$+2		;LIMIT<--INDEX
	LD	HL,(RPP)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		;(DE)<--(R1)=INDEX
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D		;(R2)<--(DE)=LIMIT
	JNEXT
;
	.BYTE	82H		;>R
	.BYTE	'>'
	.BYTE	'R'+$80
	.WORD	LEAVE-8
TOR:	.WORD	$+2
	POP	DE
	LD	HL,(RPP)
	DEC	HL
	LD	(HL),D		
	DEC	HL
	LD	(HL),E		;/ (R1)<--(DE)
	LD	(RPP),HL	;  (RP)<--(RP)-2
	JNEXT
;
	.BYTE	82H		;R>
	.BYTE	'R'
	.BYTE	'>'+$80
	.WORD	TOR-5
FROMR:	.WORD	$+2
	LD	HL,(RPP)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	(RPP),HL
	PUSH	DE		;(S1)<--(R1)
	JNEXT
;
	.BYTE	81H		;R
	.BYTE	'R'+$80
	.WORD	FROMR-5
RR:	.WORD	IDO+2
;
	.BYTE	82H		;0=
	.BYTE	'0'
	.BYTE	'='+$80
	.WORD	RR-4
ZEQU:	.WORD	$+2
	POP	HL
	LD	A,L
	OR	H
	LD	HL,0
	JR	NZ,ZEQU1
	INC	L		;(HL)<--TRUE
ZEQU1:	JHPUSH
;
	.BYTE	82H		;0<
	.BYTE	'0'
	.BYTE	'<'+$80
	.WORD	ZEQU-5
ZLESS:	.WORD	$+2
	POP	AF		;/ (A)<--(S1)H
	RLA			;/ (CARRY)<--BIT 7
	LD	HL,0		;  (HL)<--FALSE
	JR	NC,ZLES1
	INC	L		;  (HL)<--TRUE
ZLES1:	JHPUSH
;
	.BYTE	81H		;+
	.BYTE	'+'+$80
	.WORD	ZLESS-5
PLUS:	.WORD	$+2
	POP	DE
	POP	HL
	ADD	HL,DE
	JHPUSH
;
	.BYTE	82H		;D+ ( d1L d1H d2L d2h -- d3L d3H)
	.BYTE	'D'
	.BYTE	'+'+$80
	.WORD	PLUS-4
DPLUS:	.WORD	$+2
	EXX			;/ SAVE IP
	POP	BC		;  (BC)<--d2H
	POP	HL		;  (HL)<--d2L
	POP	AF		;d (AF)<--d1H
	POP	DE		;  (DE)<--d1L
	PUSH	AF		;/ (S1)<--d1H
	ADD	HL,DE		;  (HL)<--d2L+d1L=d3L
	EX	DE,HL		;  (DE)<--d3L
	POP	HL		;  (HL)<--d1H
	ADC	HL,BC		;/ (HL)<--d1H+d2H+CARRY=d3H
	PUSH	DE		;  (S2)<--d3L
	PUSH	HL		;/ (S1)<--d3H
	EXX			;/ RESTORE IP
	JNEXT
;
	.BYTE	85H		;MINUS
	.TEXT	"MINU"
	.BYTE	'S'+$80
	.WORD	DPLUS-5
MINUS:	.WORD	$+2
	POP	DE		;/
	XOR	A		;/ RESET CARRY, (A)<--0
	LD	H,A		;/
	LD	L,A		;/ LD HL,0
	SBC	HL,DE		;/ (HL)<--(DE)2's COMPL.
	JHPUSH
;
	.BYTE	86H		;DMINUS
	.TEXT	"DMINU"
	.BYTE	'S'+$80
	.WORD	MINUS-8
DMINU:	.WORD	$+2
	POP	HL		;(HL)<--d1H
	POP	DE		;(DE)<--d1L
	SUB	A		;(A)<--0
	SUB	E
	LD	E,A		;(E)<--NEG(E)
	LD	A,00H
	SBC	A,D
	LD	D,A		;(D)<--NEG(D)
	LD	A,00H
	SBC	A,L
	LD	L,A		;(L)<--NEG(L)
	LD	A,00H
	SBC	A,H
	LD	H,A		;(H)<--NEG(H)
	JP	DPUSH		;(S2)<--d2L, (S1)<--d2H
;
	.BYTE	84H		;OVER
	.TEXT	"OVE"
	.BYTE	'R'+$80
	.WORD	DMINU-9
OVER:	.WORD	$+2
	POP	DE
	POP	HL
	PUSH	HL
	JP	DPUSH
;
	.BYTE	84H		;DROP
	.TEXT	"DRO"
	.BYTE	'P'+$80
	.WORD	OVER-7
DROP:	.WORD	$+2
	POP	HL
	JNEXT
;
	.BYTE	84H		;SWAP
	.TEXT	"SWA"
	.BYTE	'P'+$80
	.WORD	DROP-7
SWAP:	.WORD	$+2
	POP	HL
	EX	(SP),HL
	JHPUSH
;
	.BYTE	83H		;DUP
	.TEXT	"DU"
	.BYTE	'P'+$80
	.WORD	SWAP-7
DUP:	.WORD	$+2
	POP	HL
	PUSH	HL
	JHPUSH
;
	.BYTE	84H		;2DUP
	.TEXT	"2DU"
	.BYTE	'P'+$80
	.WORD	DUP-6
TDUP:	.WORD	$+2
	POP	HL
	POP	DE
	PUSH	DE
	PUSH	HL
	JP	DPUSH
;
	.BYTE	82H		;+!
	.BYTE	'+'
	.BYTE	'!'+$80
	.WORD	TDUP-7
PSTOR:	.WORD	$+2
	POP	HL		;(HL)<--VAR ADDR
	POP	DE		;(DE)<--NUMBER
	LD	A,(HL)
	ADD	A,E
	LD	(HL),A
	INC	HL
	LD	A,(HL)
	ADC	A,D
	LD	(HL),A		;((HL))<--((HL))+NUMBER
	JNEXT
;
	.BYTE	86H		;TOGGLE
	.TEXT	"TOGGL"
	.BYTE	'E'+$80
	.WORD	PSTOR-5
TOGGL:	.WORD	$+2
	POP	DE		;(E)<--BIT PATTERN
	POP	HL		;(HL)<--ADDR
	LD	A,(HL)
	XOR	E
	LD	(HL),A
	JNEXT
;
	.BYTE	81H		;@
	.BYTE	'@'+$80
	.WORD	TOGGL-9
AT:	.WORD	$+2
	POP	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	PUSH	DE
	JNEXT
;
	.BYTE	82H		;C@
	.BYTE	'C'
	.BYTE	'@'+$80
	.WORD	AT-4
CAT:	.WORD	$+2
	POP	HL
	LD	L,(HL)
	LD	H,0
	JHPUSH
;
	.BYTE	82H		;2@
	.BYTE	'2'
	.BYTE	'@'+$80
	.WORD	CAT-5
TAT:	.WORD	$+2
	EXX			;/ SAVE IP
	POP	HL		;  (HL)<--ADDR
	LD	C,(HL)
	INC	HL
	LD	B,(HL)		;/ (BC)<--dH
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		;  (DE)<--dL
	PUSH	DE		;  (S2)<--dL
	PUSH	BC		;/ (S1)<--dH
	EXX			;/ RESTORE IP
	JNEXT
;
	.BYTE	81H		;!
	.BYTE	'!'+$80
	.WORD	TAT-5
STORE:	.WORD	$+2
	POP	HL
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	JNEXT
;
	.BYTE	82H		;C!
	.BYTE	'C'
	.BYTE	'!'+$80
	.WORD	STORE-4
CSTOR:	.WORD	$+2
	POP	HL
	POP	DE
	LD	(HL),E
	JNEXT
;
	.BYTE	82H		;2!
	.BYTE	'2'
	.BYTE	'!'+$80
	.WORD	CSTOR-5
TSTOR:	.WORD	$+2
	POP	HL
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	POP	DE
	LD	(HL),E
	INC	HL
	LD	(HL),D
	JNEXT
;
	.BYTE	0C1H		; :
	.BYTE	':'+$80
	.WORD	TSTOR-5
COLON:	.WORD	DOCOL
	.WORD	QEXEC
	.WORD	SCSP
	.WORD	CURR
	.WORD	AT
	.WORD	CONT
	.WORD	STORE
	.WORD	CREAT
	.WORD	RBRAC
	.WORD	PSCOD
DOCOL:	LD	HL,(RPP)
	DEC	HL
	LD	(HL),B
	DEC	HL
	LD	(HL),C
	LD	(RPP),HL
	INC	DE
	LD	C,E
	LD	B,D
	JNEXT
;
	.BYTE	0C1H		; ;
	.BYTE	';'+$80
	.WORD	COLON-4
SEMI:	.WORD	DOCOL
	.WORD	QCSP
	.WORD	COMP
	.WORD	SEMIS
	.WORD	SMUDG
	.WORD	LBRAC
	.WORD	SEMIS
;
	.BYTE	84H		;NOOP
	.TEXT	"NOO"
	.BYTE	'P'+$80
	.WORD	SEMI-4
NOOP:	.WORD	DOCOL
	.WORD	SEMIS
;
	.BYTE	88H		;CONSTANT
	.TEXT	"CONSTAN"
	.BYTE	'T'+$80
	.WORD	NOOP-7
CON:	.WORD	DOCOL
	.WORD	CREAT
	.WORD	SMUDG
	.WORD	COMMA
	.WORD	PSCOD
DOCON:	INC	DE
	EX	DE,HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	PUSH	DE
	JNEXT
;
	.BYTE	88H		;VARIABLE
	.TEXT	"VARIABL"
	.BYTE	'E'+$80
	.WORD	CON-0BH
VAR:	.WORD	DOCOL
	.WORD	CON
	.WORD	PSCOD
DOVAR:	INC	DE
	PUSH	DE
	JNEXT
;
	.BYTE	84H		;USER
	.TEXT	"USE"
	.BYTE	'R'+$80
	.WORD	VAR-0BH
USER:	.WORD	DOCOL
	.WORD	CON
	.WORD	PSCOD
DOUSE:	INC	DE
	EX	DE,HL
	LD	E,(HL)
	LD	D,00H
	LD	HL,(UP)
	ADD	HL,DE
	JHPUSH
;
	.BYTE	81H		;0
	.BYTE	'0'+$80
	.WORD	USER-7
ZERO:	.WORD	$+2		;/
	LD	HL,0		;/
	JHPUSH			;/
;
	.BYTE	81H		;1
	.BYTE	'1'+$80
	.WORD	ZERO-4
ONE:	.WORD	$+2		;/
	LD	HL,1		;/
	JHPUSH			;/
;
	.BYTE	81H		;2
	.BYTE	'2'+$80
	.WORD	ONE-4
TWO:	.WORD	$+2		;/
	LD	HL,2		;/
	JHPUSH			;/
;
	.BYTE	81H		;3
	.BYTE	'3'+$80
	.WORD	TWO-4
THREE:	.WORD	$+2		;/
	LD	HL,3		;/
	JHPUSH			;/
;
	.BYTE	82H		;BL
	.BYTE	'B'
	.BYTE	'L'+$80
	.WORD	THREE-4
BL:	.WORD	DOCON
	.WORD	20H
;
	.BYTE	83H		;C/L
	.TEXT	"C/"
	.BYTE	'L'+$80
	.WORD	BL-5
CSLL:	.WORD	DOCON
	.WORD	64
;
	.BYTE	85H		;FIRST
	.TEXT	"FIRS"
	.BYTE	'T'+$80
	.WORD	CSLL-6
FIRST:	.WORD	DOCON
	.WORD	0		;/ set by CLD
;
	.BYTE	85H		;LIMIT
	.TEXT	"LIMI"
	.BYTE	'T'+$80
	.WORD	FIRST-8
LIMIT:	.WORD	DOCON
	.WORD	0		;/ set by CLD
;
	.BYTE	85H		;B/BUF
	.TEXT	"B/BU"
	.BYTE	'F'+$80
	.WORD	LIMIT-8
BBUF:	.WORD	DOCON
	.WORD	KBBUF
;
	.BYTE	85H		;B/SCR
	.TEXT	"B/SC"
	.BYTE	'R'+$80
	.WORD	BBUF-8
BSCR:	.WORD	DOCON
	.WORD	400H/KBBUF
;
	.BYTE	87H		;+ORIGIN
	.TEXT	"+ORIGI"
	.BYTE	'N'+$80
	.WORD	BSCR-8
PORIG:	.WORD	DOCOL
	.WORD	LIT
	.WORD	ORIG
	.WORD	PLUS
	.WORD	SEMIS
;
;	USER VARIABLES
;
	.BYTE	82H		;S0
	.BYTE	'S'
	.BYTE	'0'+$80
	.WORD	PORIG-0AH
SZERO:	.WORD	DOUSE
	.WORD	6
;
	.BYTE	82H		;R0
	.BYTE	'R'
	.BYTE	'0'+$80
	.WORD	SZERO-5
RZERO:	.WORD	DOUSE
	.WORD	8
;
	.BYTE	83H		;TIB
	.TEXT	"TI"
	.BYTE	'B'+$80
	.WORD	RZERO-5
TIB:	.WORD	DOUSE
	.BYTE	0AH
;
	.BYTE	85H		;WIDTH
	.TEXT	"WIDT"
	.BYTE	'H'+$80
	.WORD	TIB-6
WIDTH:	.WORD	DOUSE
	.BYTE	0CH
;
	.BYTE	87H		;WARNING
	.TEXT	"WARNIN"
	.BYTE	'G'+$80
	.WORD	WIDTH-8
WARN:	.WORD	DOUSE
	.BYTE	0EH
;
	.BYTE	85H		;FENCE
	.TEXT	"FENC"
	.BYTE	'E'+$80
	.WORD	WARN-0AH
FENCE:	.WORD	DOUSE
	.BYTE	10H
;
	.BYTE	82H		;DP
	.BYTE	'D'
	.BYTE	'P'+$80
	.WORD	FENCE-8
DP:	.WORD	DOUSE
	.BYTE	12H
;
	.BYTE	88H		;VOC-LINK
	.TEXT	"VOC-LIN"
	.BYTE	'K'+$80
	.WORD	DP-5
VOCL:	.WORD	DOUSE
	.WORD	14H
;
	.BYTE	83H		;BLK
	.TEXT	"BL"
	.BYTE	'K'+$80
	.WORD	VOCL-0BH
BLK:	.WORD	DOUSE
	.BYTE	16H
;
	.BYTE	82H		;IN
	.BYTE	'I'
	.BYTE	'N'+$80
	.WORD	BLK-6
INN:	.WORD	DOUSE
	.BYTE	18H
;
	.BYTE	83H		;OUT
	.TEXT	"OU"
	.BYTE	'T'+$80
	.WORD	INN-5
OUTT:	.WORD	DOUSE
	.BYTE	1AH
;
	.BYTE	83H		;SCR
	.TEXT	"SC"
	.BYTE	'R'+$80
	.WORD	OUTT-6
SCR:	.WORD	DOUSE
	.BYTE	1CH
;
	.BYTE	86H		;OFFSET
	.TEXT	"OFFSE"
	.BYTE	'T'+$80
	.WORD	SCR-6
OFSET:	.WORD	DOUSE
	.BYTE	1EH
;
	.BYTE	87H		;CONTEXT
	.TEXT	"CONTEX"
	.BYTE	'T'+$80
	.WORD	OFSET-9
CONT:	.WORD	DOUSE
	.BYTE	20H
;
	.BYTE	87H		;CURRENT
	.TEXT	"CURREN"
	.BYTE	'T'+$80
	.WORD	CONT-0AH
CURR:	.WORD	DOUSE
	.BYTE	22H
;
	.BYTE	85H		;STATE
	.TEXT	"STAT"
	.BYTE	'E'+$80
	.WORD	CURR-0AH
STATE:	.WORD	DOUSE
	.BYTE	24H
;
	.BYTE	84H		;BASE
	.TEXT	"BAS"
	.BYTE	'E'+$80
	.WORD	STATE-8
BASE:	.WORD	DOUSE
	.BYTE	26H
;
	.BYTE	83H		;DPL
	.TEXT	"DP"
	.BYTE	'L'+$80
	.WORD	BASE-7
DPL:	.WORD	DOUSE
	.BYTE	28H
;
	.BYTE	83H		;FLD
	.TEXT	"FL"
	.BYTE	'D'+$80
	.WORD	DPL-6
FLD:	.WORD	DOUSE
	.BYTE	2AH
;
	.BYTE	83H		;CSP
	.TEXT	"CS"
	.BYTE	'P'+$80
	.WORD	FLD-6
CSPP:	.WORD	DOUSE
	.BYTE	2CH
;
	.BYTE	82H		;R#
	.BYTE	'R'
	.BYTE	'#'+$80
	.WORD	CSPP-6
RNUM:	.WORD	DOUSE
	.BYTE	2EH
;
	.BYTE	83H		;HLD
	.TEXT	"HL"
	.BYTE	'D'+$80
	.WORD	RNUM-5
HLD:	.WORD	DOUSE
	.WORD	30H
;
;	END OF USER VARIABLES
;
	.BYTE	82H		;1+
	.BYTE	'1'
	.BYTE	'+'+$80
	.WORD	HLD-6
ONEP:	.WORD	$+2		;/
	POP	HL		;/
	INC	HL		;/
	JHPUSH			;/
;
	.BYTE	82H		;2+
	.BYTE	'2'
	.BYTE	'+'+$80
	.WORD	ONEP-5
TWOP:	.WORD	$+2		;/
	POP	HL		;/
	INC	HL		;/
	INC	HL		;/
	JHPUSH			;/
;
	.BYTE	82H		;/ 1-
	.BYTE	'1'
	.BYTE	'-'+$80		;/
	.WORD	TWOP-5		;/
ONEMIN:	.WORD	$+2		;/
	POP	HL		;/
	DEC	HL		;/
	JHPUSH			;/
;
	.BYTE	82H		;/ 2-
	.BYTE	'2'
	.BYTE	'-'+$80		;/
	.WORD	ONEMIN-5	;/
TWOMIN:	.WORD	$+2		;/
	POP	HL		;/
	DEC	HL		;/
	DEC	HL		;/
	JHPUSH			;/
;
	.BYTE	82H		;/ 2*
	.BYTE	'2'
	.BYTE	'*'+$80		;/
	.WORD	TWOMIN-5	;/
TWOSTA:	.WORD	$+2		;/
	POP	HL		;/
	ADD	HL,HL		;/ ASL HL
	JHPUSH			;/
;
	.BYTE	82H		;/ 2/
	.BYTE	'2'
	.BYTE	'/'+$80		;/
	.WORD	TWOSTA-5	;/
TWOSLA:	.WORD	$+2		;/
	POP	HL		;/
	BIT	7,H		;/
	JR	Z,TWOSL1	;/
	INC	HL		;/
TWOSL1:	SRA	H		;/
	RR	L		;/ ASR HL
	JHPUSH			;/
;
	.BYTE	84H		;HERE
	.TEXT	"HER"
	.BYTE	'E'+$80
	.WORD	TWOSLA-5
HERE:	.WORD	DOCOL
	.WORD	DP
	.WORD	AT
	.WORD	SEMIS
;
	.BYTE	85H		;ALLOT
	.TEXT	"ALLO"
	.BYTE	'T'+$80
	.WORD	HERE-7
ALLOT:	.WORD	DOCOL
	.WORD	DP
	.WORD	PSTOR
	.WORD	SEMIS
;
	.BYTE	81H		; ,
	.BYTE	','+$80
	.WORD	ALLOT-8
COMMA:	.WORD	DOCOL
	.WORD	HERE
	.WORD	STORE
	.WORD	TWO
	.WORD	ALLOT
	.WORD	SEMIS
;
	.BYTE	82H		;C,
	.BYTE	'C'
	.BYTE	','+$80
	.WORD	COMMA-4
CCOMM:	.WORD	DOCOL
	.WORD	HERE
	.WORD	CSTOR
	.WORD	ONE
	.WORD	ALLOT
	.WORD	SEMIS
;
	.BYTE	81H		;-
	.BYTE	'-'+$80
	.WORD	CCOMM-5
SUBB:	.WORD	$+2
	POP	DE
	POP	HL
	OR	A		;/ RESET CARRY
	SBC	HL,DE		;/
	JHPUSH
;
	.BYTE	81H		;=
	.BYTE	'='+$80
	.WORD	SUBB-4
EQUAL:	.WORD	$+2		;/
	POP	DE		;/
	POP	HL		;/
	XOR	A		;/ RESET CARRY
	SBC	HL,DE		;/
	LD	H,A		;/
	LD	L,A		;/ LD HL,0000H
	JR	NZ,EXEQU	;/ FALSE
	INC	L		;/ TRUE
EXEQU:	JHPUSH			;/
;
	.BYTE	81H		;  <
	.BYTE	'<'+$80
	.WORD	EQUAL-4
LESS:	.WORD	$+2
	POP	DE
	POP	HL		;  (HL) (DE) <
	LD	A,D
	XOR	H		;  ONE OF THEM NEGATIVE?
	JP	M,LES1		;  YES, DETERMINE WHICH
	OR	A		;/ CLR CARRY
	SBC	HL,DE		;/
LES1:	BIT	7,H		;/ (H) NEGATIVE?
	LD	HL,0
	JR	Z,EXLESS	;/ NO, FALSE
	INC	L		;/ TRUE
EXLESS:	JHPUSH
;
	.BYTE	82H		;U<
	.BYTE	'U'
	.BYTE	'<'+$80
	.WORD	LESS-4
ULESS:	.WORD	$+2		;/
	POP	DE
	POP	HL		;/ (HL) (DE) U<
	XOR	A		;/
	SBC	HL,DE		;/
	LD	H,A		;/
	LD	L,A		;/ LD HL,0000H
	JR	NC,EXULES	;/ FALSE
	INC	L		;/ TRUE
EXULES:	JHPUSH
;
	.BYTE	81H		;>
	.BYTE	'>'+$80
	.WORD	ULESS-5
GREAT:	.WORD	$+2
	POP	HL		;/
	POP	DE		;/ (HL) (DE) > = (DE) (HL) <
	LD	A,D
	XOR	H		;  ONE OF THEM NEGATIVE?
	JP	M,GREAT1	;  YES, DETERMINE WHICH
	OR	A		;/ CLR CARRY
	SBC	HL,DE		;/
GREAT1:	BIT	7,H		;/ (H) NEGATIVE?
	LD	HL,0		;  (HL)<--FALSE
	JR	Z,GREAT2	;/ NO, FALSE
	INC	L		;/ (HL)<--TRUE
GREAT2:	JHPUSH
;
	.BYTE	83H		;ROT
	.TEXT	"RO"
	.BYTE	'T'+$80
	.WORD	GREAT-4
ROT:	.WORD	$+2
	POP	DE
	POP	HL
	EX	(SP),HL
	JP	DPUSH
;
	.BYTE	85H		;SPACE
	.TEXT	"SPAC"
	.BYTE	'E'+$80
	.WORD	ROT-6
SPACE:	.WORD	DOCOL
	.WORD	BL
	.WORD	EMIT
	.WORD	SEMIS
;
	.BYTE	84H		;-DUP
	.TEXT	"-DU"
	.BYTE	'P'+$80
	.WORD	SPACE-8
DDUP:	.WORD	$+2		;/
	POP	HL		;/
	LD	A,H		;/
	OR	L		;/ (HL)=0?
	JR	Z,EXDDUP	;/ YES, DON'T DUP
	PUSH	HL		;/
EXDDUP:	JHPUSH
;
	.BYTE	88H		;TRAVERSE
	.TEXT	"TRAVERS"
	.BYTE	'E'+$80
	.WORD	DDUP-7
TRAV:	.WORD	DOCOL
	.WORD	SWAP
TRAV1:	.WORD	OVER		;BEGIN
	.WORD	PLUS
	.WORD	LIT
	.WORD	7FH
	.WORD	OVER
	.WORD	CAT
	.WORD	LESS
	.WORD	ZBRAN		;UNTIL
	.WORD	TRAV1-$
	.WORD	SWAP
	.WORD	DROP
	.WORD	SEMIS
;
	.BYTE	86H		;LATEST
	.TEXT	"LATES"
	.BYTE	'T'+$80
	.WORD	TRAV-0BH
LATES:	.WORD	DOCOL
	.WORD	CURR
	.WORD	AT
	.WORD	AT
	.WORD	SEMIS
;
	.BYTE	83H		;LFA
	.TEXT	"LF"
	.BYTE	'A'+$80
	.WORD	LATES-9
LFA:	.WORD	$+2		;/
	POP	HL		;/ (HL)<--PFA
	DEC	HL		;/
	DEC	HL		;/
	DEC	HL		;/
	DEC	HL		;/ (HL)<--(HL)-4 = LFA
	JHPUSH			;/
;
	.BYTE	83H		;CFA
	.TEXT	"CF"
	.BYTE	'A'+$80
	.WORD	LFA-6
CFA:	.WORD	DOCOL
	.WORD	TWOMIN		;/
	.WORD	SEMIS
;
	.BYTE	83H		;NFA
	.TEXT	"NF"
	.BYTE	'A'+$80
	.WORD	CFA-6
NFA:	.WORD	DOCOL
	.WORD	LIT
	.WORD	5
	.WORD	SUBB
	.WORD	LIT
	.WORD	-1
	.WORD	TRAV
	.WORD	SEMIS
;
	.BYTE	83H		;PFA
	.TEXT	"PF"
	.BYTE	'A'+$80
	.WORD	NFA-6
PFA:	.WORD	DOCOL
	.WORD	ONE
	.WORD	TRAV
	.WORD	LIT
	.WORD	5
	.WORD	PLUS
	.WORD	SEMIS
;
	.BYTE	84H		;!CSP
	.TEXT	"!CS"
	.BYTE	'P'+$80
	.WORD	PFA-6
SCSP:	.WORD	DOCOL
	.WORD	SPAT
	.WORD	CSPP
	.WORD	STORE
	.WORD	SEMIS
;
	.BYTE	86H		;?ERROR
	.TEXT	"?ERRO"
	.BYTE	'R'+$80
	.WORD	SCSP-7
QERR:	.WORD	DOCOL
	.WORD	SWAP
	.WORD	ZBRAN		;IF
	.WORD	QERR1-$
	.WORD	ERROR
	.WORD	BRAN		;ELSE
	.WORD	QERR2-$
QERR1:	.WORD	DROP		;ENDIF
QERR2:	.WORD	SEMIS
;
	.BYTE	85H		;?COMP
	.TEXT	"?COM"
	.BYTE	'P'+$80
	.WORD	QERR-9
QCOMP:	.WORD	DOCOL
	.WORD	STATE
	.WORD	AT
	.WORD	ZEQU
	.WORD	LIT
	.WORD	11H
	.WORD	QERR
	.WORD	SEMIS
;
	.BYTE	85H		;?EXEC
	.TEXT	"?EXE"
	.BYTE	'C'+$80
	.WORD	QCOMP-8
QEXEC:	.WORD	DOCOL
	.WORD	STATE
	.WORD	AT
	.WORD	LIT
	.WORD	12H
	.WORD	QERR
	.WORD	SEMIS
;
	.BYTE	86H		;?PAIRS
	.TEXT	"?PAIR"
	.BYTE	'S'+$80
	.WORD	QEXEC-8
QPAIR:	.WORD	DOCOL
	.WORD	SUBB
	.WORD	LIT
	.WORD	13H
	.WORD	QERR
	.WORD	SEMIS
;
	.BYTE	84H		;?CSP
	.TEXT	"?CS"
	.BYTE	'P'+$80
	.WORD	QPAIR-9
QCSP:	.WORD	DOCOL
	.WORD	SPAT
	.WORD	CSPP
	.WORD	AT
	.WORD	SUBB
	.WORD	LIT
	.WORD	14H
	.WORD	QERR
	.WORD	SEMIS
;
	.BYTE	88H		;?LOADING
	.TEXT	"?LOADIN"
	.BYTE	'G'+$80
	.WORD	QCSP-7
QLOAD:	.WORD	DOCOL
	.WORD	BLK
	.WORD	AT
	.WORD	ZEQU
	.WORD	LIT
	.WORD	16H
	.WORD	QERR
	.WORD	SEMIS
;
	.BYTE	87H		;COMPILE
	.TEXT	"COMPIL"
	.BYTE	'E'+$80
	.WORD	QLOAD-0BH
COMP:	.WORD	DOCOL
	.WORD	QCOMP
	.WORD	FROMR
	.WORD	DUP
	.WORD	TWOP
	.WORD	TOR
	.WORD	AT
	.WORD	COMMA
	.WORD	SEMIS
;
	.BYTE	0C1H		;[
	.BYTE	'['+$80
	.WORD	COMP-0AH
LBRAC:	.WORD	DOCOL
	.WORD	ZERO
	.WORD	STATE
	.WORD	STORE
	.WORD	SEMIS
;
	.BYTE	81H		;]
	.BYTE	']'+$80
	.WORD	LBRAC-4
RBRAC:	.WORD	DOCOL
	.WORD	LIT,0C0H
	.WORD	STATE,STORE
	.WORD	SEMIS
;
	.BYTE	86H		;SMUDGE
	.TEXT	"SMUDG"
	.BYTE	'E'+$80
	.WORD	RBRAC-4
SMUDG:	.WORD	DOCOL
	.WORD	LATES
	.WORD	LIT
	.WORD	20H
	.WORD	TOGGL
	.WORD	SEMIS
;
	.BYTE	83H		;HEX
	.TEXT	"HE"
	.BYTE	'X'+$80
	.WORD	SMUDG-9
HEX:	.WORD	DOCOL
	.WORD	LIT
	.WORD	10H
	.WORD	BASE
	.WORD	STORE
	.WORD	SEMIS
;
	.BYTE	87H		;DECIMAL
	.TEXT	"DECIMA"
	.BYTE	'L'+$80
	.WORD	HEX-6
DEC:	.WORD	DOCOL
	.WORD	LIT
	.WORD	0AH
	.WORD	BASE
	.WORD	STORE
	.WORD	SEMIS
;
	.BYTE	87H		;(;CODE)
	.TEXT	"(;CODE"
	.BYTE	')'+$80
	.WORD	DEC-0AH
PSCOD:	.WORD	DOCOL
	.WORD	FROMR
	.WORD	LATES
	.WORD	PFA
	.WORD	CFA
	.WORD	STORE
	.WORD	SEMIS
;
	.BYTE	0C5H		; ;CODE
	.TEXT	";COD"
	.BYTE	'E'+$80
	.WORD	PSCOD-0AH
SEMIC:	.WORD	DOCOL
	.WORD	QCSP
	.WORD	COMP
	.WORD	PSCOD
	.WORD	LBRAC
SEMI1:	.WORD	NOOP		;ASSEMBLER
	.WORD	SEMIS
;
	.BYTE	87H		;<BUILDS
	.TEXT	"<BUILD"
	.BYTE	'S'+$80
	.WORD	SEMIC-8
BUILD:	.WORD	DOCOL
	.WORD	ZERO
	.WORD	CON
	.WORD	SEMIS
;
	.BYTE	85H		;DOES>
	.TEXT	"DOES"
	.BYTE	'>'+$80
	.WORD	BUILD-0AH
DOES:	.WORD	DOCOL
	.WORD	FROMR
	.WORD	LATES
	.WORD	PFA
	.WORD	STORE
	.WORD	PSCOD
DODOE:	LD	HL,(RPP)
	DEC	HL
	LD	(HL),B
	DEC	HL
	LD	(HL),C
	LD	(RPP),HL
	INC	DE
	EX	DE,HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	INC	HL
	JHPUSH
;
	.BYTE	85H		;COUNT
	.TEXT	"COUN"
	.BYTE	'T'+$80
	.WORD	DOES-8
COUNT:	.WORD	DOCOL
	.WORD	DUP
	.WORD	ONEP
	.WORD	SWAP
	.WORD	CAT
	.WORD	SEMIS
;
	.BYTE	84H		;TYPE
	.TEXT	"TYP"
	.BYTE	'E'+$80
	.WORD	COUNT-8
TYPE:	.WORD	DOCOL
	.WORD	DDUP
	.WORD	ZBRAN		;IF
	.WORD	TYPE1-$
	.WORD	OVER
	.WORD	PLUS
	.WORD	SWAP
	.WORD	XDO		;DO
TYPE2:	.WORD	IDO
	.WORD	CAT
	.WORD	EMIT
	.WORD	XLOOP		;LOOP
	.WORD	TYPE2-$
	.WORD	BRAN		;ELSE
	.WORD	TYPE3-$
TYPE1:	.WORD	DROP		;ENDIF
TYPE3:	.WORD	SEMIS
;
	.BYTE	89H		;-TRAILING
	.TEXT	"-TRAILIN"
	.BYTE	'G'+$80
	.WORD	TYPE-7
DTRAI:	.WORD	DOCOL
	.WORD	DUP
	.WORD	ZERO
	.WORD	XDO		;DO
DTRA1:	.WORD	TDUP		;/
	.WORD	PLUS
	.WORD	ONEMIN		;/
	.WORD	CAT
	.WORD	BL
	.WORD	SUBB
	.WORD	ZBRAN		;IF
	.WORD	DTRA2-$
	.WORD	LEAVE
	.WORD	BRAN		;ELSE
	.WORD	DTRA3-$
DTRA2:	.WORD	ONEMIN		;/
DTRA3:	.WORD	XLOOP		;LOOP
	.WORD	DTRA1-$
	.WORD	SEMIS
;
	.BYTE	84H		;(.")
	.TEXT	"(.\""
	.BYTE	')'+$80
	.WORD	DTRAI-0CH
PDOTQ:	.WORD	DOCOL
	.WORD	RR
	.WORD	COUNT
	.WORD	DUP
	.WORD	ONEP
	.WORD	FROMR
	.WORD	PLUS
	.WORD	TOR
	.WORD	TYPE
	.WORD	SEMIS
;
	.BYTE	0C2H		;."
	.BYTE	'.'
	.BYTE	'"'+$80
	.WORD	PDOTQ-7
DOTQ:	.WORD	DOCOL
	.WORD	LIT
	.WORD	22H
	.WORD	STATE
	.WORD	AT
	.WORD	ZBRAN		;IF
	.WORD	DOTQ1-$
	.WORD	COMP
	.WORD	PDOTQ
	.WORD	WORD
	.WORD	HERE
	.WORD	CAT
	.WORD	ONEP
	.WORD	ALLOT
	.WORD	BRAN		;ELSE
	.WORD	DOTQ2-$
DOTQ1:	.WORD	WORD
	.WORD	HERE
	.WORD	COUNT
	.WORD	TYPE		;ENDIF
DOTQ2:	.WORD	SEMIS
;
	.BYTE	86H		;EXPECT
	.TEXT	"EXPEC"
	.BYTE	'T'+$80
	.WORD	DOTQ-5
EXPEC:	.WORD	DOCOL
	.WORD	OVER
	.WORD	PLUS
	.WORD	OVER
	.WORD	XDO		;DO
EXPE1:	.WORD	KEY
	.WORD	DUP
	.WORD	LIT
	.WORD	0EH
	.WORD	PORIG
	.WORD	AT
	.WORD	EQUAL
	.WORD	ZBRAN		;IF
	.WORD	EXPE2-$
	.WORD	DROP
	.WORD	DUP
	.WORD	IDO
	.WORD	EQUAL
	.WORD	DUP
	.WORD	FROMR
	.WORD	TWOMIN		;/
	.WORD	PLUS
	.WORD	TOR
	.WORD	ZBRAN		;IF
	.WORD	EXPE6-$
	.WORD	LIT
	.WORD	BELL
	.WORD	BRAN		;ELSE
	.WORD	EXPE7-$
EXPE6:	.WORD	LIT
	.WORD	BSOUT		;ENDIF
EXPE7:	.WORD	BRAN		;ELSE
	.WORD	EXPE3-$
EXPE2:	.WORD	DUP
	.WORD	LIT
	.WORD	ACR		;/
	.WORD	EQUAL
	.WORD	ZBRAN		;IF
	.WORD	EXPE4-$
	.WORD	LEAVE
	.WORD	DROP
	.WORD	BL
	.WORD	ZERO
	.WORD	BRAN		;ELSE
	.WORD	EXPE5-$
EXPE4:	.WORD	DUP		;ENDIF
EXPE5:	.WORD	IDO
	.WORD	CSTOR
	.WORD	ZERO
	.WORD	IDO
	.WORD	ONEP
	.WORD	STORE		;ENDIF
EXPE3:	.WORD	EMIT
	.WORD	XLOOP		;LOOP
	.WORD	EXPE1-$
	.WORD	DROP
	.WORD	SEMIS
;
	.BYTE	85H		;QUERY
	.TEXT	"QUER"
	.BYTE	'Y'+$80
	.WORD	EXPEC-9
QUERY:	.WORD	DOCOL
	.WORD	TIB
	.WORD	AT
	.WORD	LIT
	.WORD	50H
	.WORD	EXPEC
	.WORD	ZERO
	.WORD	INN
	.WORD	STORE
	.WORD	SEMIS
;
	.BYTE	0C1H		;NULL
	.BYTE	80H
	.WORD	QUERY-8
NULL:	.WORD	DOCOL
	.WORD	BLK
	.WORD	AT
	.WORD	ZBRAN		;IF
	.WORD	NULL1-$
	.WORD	ONE
	.WORD	BLK
	.WORD	PSTOR
	.WORD	ZERO
	.WORD	INN
	.WORD	STORE
	.WORD	BLK
	.WORD	AT
	.WORD	BSCR
	.WORD	ONEMIN		;/
	.WORD	ANDD
	.WORD	ZEQU
	.WORD	ZBRAN		;IF
	.WORD	NULL2-$
	.WORD	QEXEC
	.WORD	FROMR
	.WORD	DROP		;ENDIF
NULL2:	.WORD	BRAN		;ELSE
	.WORD	NULL3-$
NULL1:	.WORD	FROMR
	.WORD	DROP		;ENDIF
NULL3:	.WORD	SEMIS
;
	.BYTE	84H		;FILL
	.TEXT	"FIL"
	.BYTE	'L'+$80
	.WORD	NULL-4
FILL:	.WORD	$+2
	EXX			;/ SAVE IP
	POP	DE		;/ (E)<--BYTE
	POP	BC		;  (BC)<--QUANTITY
	POP	HL		;/ (HL)<--ADDR
FILL1:	LD	A,B
	OR	C		;  QTY=0?
	JR	Z,FILL2		;  YES
	LD	(HL),E		;/ ((HL))<--BYTE
	INC	HL		;  INC POINTER
	DEC	BC		;  DEC COUNTER
	JP	FILL1		;/
FILL2:	EXX			;/ RESTORE IP
	JNEXT
;
	.BYTE	85H		;ERASE
	.TEXT	"ERAS"
	.BYTE	'E'+$80
	.WORD	FILL-7
ERASEE:	.WORD	DOCOL
	.WORD	ZERO
	.WORD	FILL
	.WORD	SEMIS
;
	.BYTE	86H		;BLANKS
	.TEXT	"BLANK"
	.BYTE	'S'+$80
	.WORD	ERASEE-8
BLANK:	.WORD	DOCOL
	.WORD	BL
	.WORD	FILL
	.WORD	SEMIS
;
	.BYTE	84H		;HOLD
	.TEXT	"HOL"
	.BYTE	'D'+$80
	.WORD	BLANK-9
HOLD:	.WORD	DOCOL
	.WORD	LIT
	.WORD	-1
	.WORD	HLD
	.WORD	PSTOR
	.WORD	HLD
	.WORD	AT
	.WORD	CSTOR
	.WORD	SEMIS
;
	.BYTE	83H		;PAD
	.TEXT	"PA"
	.BYTE	'D'+$80
	.WORD	HOLD-7
PAD:	.WORD	DOCOL
	.WORD	HERE
	.WORD	LIT
	.WORD	44H
	.WORD	PLUS
	.WORD	SEMIS
;
	.BYTE	84H		;WORD
	.TEXT	"WOR"
	.BYTE	'D'+$80
	.WORD	PAD-6
WORD:	.WORD	DOCOL
	.WORD	BLK
	.WORD	AT
	.WORD	ZBRAN		;IF
	.WORD	WORD1-$
	.WORD	BLK
	.WORD	AT
	.WORD	BLOCK
	.WORD	BRAN		;ELSE
	.WORD	WORD2-$
WORD1:	.WORD	TIB
	.WORD	AT		;ENDIF
WORD2:	.WORD	INN
	.WORD	AT
	.WORD	PLUS
	.WORD	SWAP
	.WORD	ENCL
	.WORD	HERE
	.WORD	LIT
	.WORD	22H
	.WORD	BLANK
	.WORD	INN
	.WORD	PSTOR
	.WORD	OVER
	.WORD	SUBB
	.WORD	TOR
	.WORD	RR
	.WORD	HERE
	.WORD	CSTOR
	.WORD	PLUS
	.WORD	HERE
	.WORD	ONEP
	.WORD	FROMR
	.WORD	CMOVE
	.WORD	SEMIS
;
	.BYTE	88H		;(NUMBER)
	.TEXT	"(NUMBER"
	.BYTE	')'+$80
	.WORD	WORD-7
PNUMB:	.WORD	DOCOL
PNUM1:	.WORD	ONEP		;BEGIN
	.WORD	DUP
	.WORD	TOR
	.WORD	CAT
	.WORD	BASE
	.WORD	AT
	.WORD	DIGIT
	.WORD	ZBRAN		;WHILE
	.WORD	PNUM2-$
	.WORD	SWAP
	.WORD	BASE
	.WORD	AT
	.WORD	USTAR
	.WORD	DROP
	.WORD	ROT
	.WORD	BASE
	.WORD	AT
	.WORD	USTAR
	.WORD	DPLUS
	.WORD	DPL
	.WORD	AT
	.WORD	ONEP
	.WORD	ZBRAN		;IF
	.WORD	PNUM3-$
	.WORD	ONE
	.WORD	DPL
	.WORD	PSTOR		;ENDIF
PNUM3:	.WORD	FROMR
	.WORD	BRAN		;REPEAT
	.WORD	PNUM1-$
PNUM2:	.WORD	FROMR
	.WORD	SEMIS
;
	.BYTE	86H		;NUMBER
	.TEXT	"NUMBE"
	.BYTE	'R'+$80
	.WORD	PNUMB-0BH
NUMB:	.WORD	DOCOL
	.WORD	ZERO
	.WORD	ZERO
	.WORD	ROT
	.WORD	DUP
	.WORD	ONEP
	.WORD	CAT
	.WORD	LIT
	.WORD	2DH
	.WORD	EQUAL
	.WORD	DUP
	.WORD	TOR
	.WORD	PLUS
	.WORD	LIT
	.WORD	-1
NUMB1:	.WORD	DPL		;BEGIN
	.WORD	STORE
	.WORD	PNUMB
	.WORD	DUP
	.WORD	CAT
	.WORD	BL
	.WORD	SUBB
	.WORD	ZBRAN		;WHILE
	.WORD	NUMB2-$
	.WORD	DUP
	.WORD	CAT
	.WORD	LIT
	.WORD	2EH
	.WORD	SUBB
	.WORD	ZERO
	.WORD	QERR
	.WORD	ZERO
	.WORD	BRAN		;REPEAT
	.WORD	NUMB1-$
NUMB2:	.WORD	DROP
	.WORD	FROMR
	.WORD	ZBRAN		;IF
	.WORD	NUMB3-$
	.WORD	DMINU		;ENDIF
NUMB3:	.WORD	SEMIS
;
	.BYTE	85H		;-FIND (0-3) SUCCESS
	.TEXT	"-FIN"		;      (0-1) FAILURE
	.BYTE	'D'+$80
	.WORD	NUMB-9
DFIND:	.WORD	DOCOL
	.WORD	BL
	.WORD	WORD
	.WORD	HERE
	.WORD	CONT
	.WORD	AT
	.WORD	AT
	.WORD	PFIND
	.WORD	DUP
	.WORD	ZEQU
	.WORD	ZBRAN		;IF
	.WORD	DFIN1-$
	.WORD	DROP
	.WORD	HERE
	.WORD	LATES
	.WORD	PFIND		;ENDIF
DFIN1:	.WORD	SEMIS
;
	.BYTE	87H		;(ABORT)
	.TEXT	"(ABORT"
	.BYTE	')'+$80
	.WORD	DFIND-8
PABOR:	.WORD	DOCOL
	.WORD	ABORT
	.WORD	SEMIS
;
	.BYTE	85H		;ERROR
	.TEXT	"ERRO"
	.BYTE	'R'+$80
	.WORD	PABOR-0AH
ERROR:	.WORD	DOCOL
	.WORD	WARN
	.WORD	AT
	.WORD	ZLESS
	.WORD	ZBRAN		;IF
	.WORD	ERRO1-$
	.WORD	PABOR		;ENDIF
ERRO1:	.WORD	HERE
	.WORD	COUNT
	.WORD	TYPE
	.WORD	PDOTQ
	.BYTE	2
	.TEXT	"? "
	.WORD	MESS
	.WORD	SPSTO
;	CHANGE FROM fig MODEL
;	.WORD	INN,AT,BLK,AT
	.WORD	BLK,AT
	.WORD	DDUP
	.WORD	ZBRAN,ERRO2-$-2	;DT - IF
	.WORD	INN,AT
	.WORD	SWAP		;ENDIF
ERRO2:	.WORD	QUIT
;
	.BYTE	83H		;ID.
	.TEXT	"ID"
	.BYTE	'.'+$80
	.WORD	ERROR-8
IDDOT:	.WORD	DOCOL
	.WORD	PAD
	.WORD	LIT
	.WORD	20H
	.WORD	BLANK		;/
	.WORD	DUP
	.WORD	PFA
	.WORD	LFA
	.WORD	OVER
	.WORD	SUBB
	.WORD	DUP		;/ change frm MODEL
	.WORD	TOR		;/ to suppress BIT 7
	.WORD	PAD
	.WORD	SWAP
	.WORD	CMOVE
	.WORD	PAD
	.WORD	FROMR		;/ for terminals
	.WORD	PAD		;/ with an 8 bit
	.WORD	PLUS		;/ ASCCI character set.
	.WORD	ONEMIN		;/
	.WORD	DUP		;/
	.WORD	AT		;/
	.WORD	LIT		;/
	.WORD	7FH		;/
	.WORD	ANDD		;/
	.WORD	SWAP		;/
	.WORD	STORE		;/
	.WORD	COUNT
	.WORD	LIT
	.WORD	1FH		;  WIDTH
	.WORD	ANDD
	.WORD	TYPE
	.WORD	SPACE
	.WORD	SEMIS
;
	.BYTE	86H		;CREATE
	.TEXT	"CREAT"
	.BYTE	'E'+$80
	.WORD	IDDOT-6
CREAT:	.WORD	DOCOL
	.WORD	DFIND
	.WORD	ZBRAN		;IF
	.WORD	CREA1-$
	.WORD	DROP
	.WORD	NFA
	.WORD	IDDOT
	.WORD	LIT
	.WORD	4
	.WORD	MESS
	.WORD	SPACE		;ENDIF
CREA1:	.WORD	HERE
	.WORD	DUP
	.WORD	CAT
	.WORD	WIDTH
	.WORD	AT
	.WORD	MIN
	.WORD	ONEP
	.WORD	ALLOT
	.WORD	DUP
	.WORD	LIT
	.WORD	0A0H
	.WORD	TOGGL
	.WORD	HERE
	.WORD	ONEMIN
	.WORD	LIT
	.WORD	80H
	.WORD	TOGGL
	.WORD	LATES
	.WORD	COMMA
	.WORD	CURR
	.WORD	AT
	.WORD	STORE
	.WORD	HERE
	.WORD	TWOP
	.WORD	COMMA
	.WORD	SEMIS
;
	.BYTE	0C9H		;[COMPILE]
	.TEXT	"[COMPILE"
	.BYTE	']'+$80
	.WORD	CREAT-9
BCOMP:	.WORD	DOCOL
	.WORD	DFIND
	.WORD	ZEQU
	.WORD	ZERO
	.WORD	QERR
	.WORD	DROP
	.WORD	CFA
	.WORD	COMMA
	.WORD	SEMIS
;
	.BYTE	0C7H		;LITERAL
	.TEXT	"LITERA"
	.BYTE	'L'+$80
	.WORD	BCOMP-0CH
LITER:	.WORD	DOCOL
	.WORD	STATE
	.WORD	AT
	.WORD	ZBRAN		;IF
	.WORD	LITE1-$
	.WORD	COMP
	.WORD	LIT
	.WORD	COMMA		;ENDIF
LITE1:	.WORD	SEMIS
;
	.BYTE	0C8H		;DLITERAL
	.TEXT	"DLITERA"
	.BYTE	'L'+$80
	.WORD	LITER-0AH
DLITE:	.WORD	DOCOL
	.WORD	STATE
	.WORD	AT
	.WORD	ZBRAN		;IF
	.WORD	DLIT1-$
	.WORD	SWAP
	.WORD	LITER
	.WORD	LITER		;ENDIF
DLIT1:	.WORD	SEMIS
;
	.BYTE	86H		;?STACK
	.TEXT	"?STAC"
	.BYTE	'K'+$80
	.WORD	DLITE-0BH
QSTAC:	.WORD	DOCOL
	.WORD	SPAT
	.WORD	SZERO
	.WORD	AT
	.WORD	SWAP
	.WORD	ULESS
	.WORD	ONE
	.WORD	QERR
	.WORD	SPAT
	.WORD	HERE
	.WORD	LIT
	.WORD	80H
	.WORD	PLUS
	.WORD	ULESS
	.WORD	LIT
	.WORD	7
	.WORD	QERR
	.WORD	SEMIS
;
	.BYTE	89H		;INTERPRET
	.TEXT	"INTERPRE"
	.BYTE	'T'+$80
	.WORD	QSTAC-9
INTER:	.WORD	DOCOL
INTE1:	.WORD	DFIND		;BEGIN
	.WORD	ZBRAN		;IF
	.WORD	INTE2-$
	.WORD	STATE
	.WORD	AT
	.WORD	LESS
	.WORD	ZBRAN		;IF
	.WORD	INTE3-$
	.WORD	CFA
	.WORD	COMMA
	.WORD	BRAN		;ELSE
	.WORD	INTE4-$
INTE3:	.WORD	CFA
	.WORD	EXEC		;ENDIF
INTE4:	.WORD	QSTAC
	.WORD	BRAN		;ELSE
	.WORD	INTE5-$
INTE2:	.WORD	HERE
	.WORD	NUMB
	.WORD	DPL
	.WORD	AT
	.WORD	ONEP
	.WORD	ZBRAN		;IF
	.WORD	INTE6-$
	.WORD	DLITE
	.WORD	BRAN		;ELSE
	.WORD	INTE7-$
INTE6:	.WORD	DROP
	.WORD	LITER		;ENDIF
INTE7:	.WORD	QSTAC		;ENDIF
INTE5:	.WORD	BRAN		;AGAIN
	.WORD	INTE1-$
;
	.BYTE	89H		;IMMEDIATE
	.TEXT	"IMMEDIAT"
	.BYTE	'E'+$80
	.WORD	INTER-0CH
IMMED:	.WORD	DOCOL
	.WORD	LATES
	.WORD	LIT
	.WORD	40H
	.WORD	TOGGL
	.WORD	SEMIS
;
	.BYTE	8AH		;VOCABULARY
	.TEXT	"VOCABULAR"
	.BYTE	'Y'+$80
	.WORD	IMMED-0CH
VOCAB:	.WORD	DOCOL
	.WORD	BUILD
	.WORD	LIT
	.WORD	0A081H
	.WORD	COMMA
	.WORD	CURR
	.WORD	AT
	.WORD	CFA
	.WORD	COMMA
	.WORD	HERE
	.WORD	VOCL
	.WORD	AT
	.WORD	COMMA
	.WORD	VOCL
	.WORD	STORE
	.WORD	DOES
DOVOC:	.WORD	TWOP
	.WORD	CONT
	.WORD	STORE
	.WORD	SEMIS
;
	.BYTE	0C5H		;FORTH
	.TEXT	"FORT"
	.BYTE	'H'+$80
	.WORD	VOCAB-0DH
FORTH:	.WORD	DODOE
	.WORD	DOVOC
	.WORD	0A081H
	.WORD	TASK-7		;COLD START VALUE ONLY.
;				CHANGED EACH TIME A DEF IS APPENDED
;				TO THE FORTH VOCABULARY
	.WORD	0		;END OF VOCABULARY LIST
;
	.BYTE	8BH		;DEFINITIONS
	.TEXT	"DEFINITION"
	.BYTE	'S'+$80
	.WORD	FORTH-8
DEFIN:	.WORD	DOCOL
	.WORD	CONT
	.WORD	AT
	.WORD	CURR
	.WORD	STORE
	.WORD	SEMIS
;
	.BYTE	0C1H		;(
	.BYTE	'('+$80
	.WORD	DEFIN-0EH
PAREN:	.WORD	DOCOL
	.WORD	LIT
	.WORD	29H
	.WORD	WORD
	.WORD	SEMIS
;
	.BYTE	84H		;QUIT
	.TEXT	"QUI"
	.BYTE	'T'+$80
	.WORD	PAREN-4
QUIT:	.WORD	DOCOL
	.WORD	ZERO
	.WORD	BLK
	.WORD	STORE
	.WORD	LBRAC
QUIT1:	.WORD	RPSTO		;BEGIN
	.WORD	CR
	.WORD	QUERY
	.WORD	INTER
	.WORD	STATE
	.WORD	AT
	.WORD	ZEQU
	.WORD	ZBRAN		;IF
	.WORD	QUIT2-$
	.WORD	PDOTQ
	.BYTE	2
	.TEXT	"ok"		;ENDIF
QUIT2:	.WORD	BRAN		;AGAIN
	.WORD	QUIT1-$
;
	.BYTE	85H		;ABORT
	.TEXT	"ABOR"
	.BYTE	'T'+$80
	.WORD	QUIT-7
ABORT:	.WORD	DOCOL
	.WORD	SPSTO
	.WORD	DEC
	.WORD	QSTAC
	.WORD	CR
	.WORD	DOTCPU
	.WORD	PDOTQ
	.BYTE	0EH		;count of CHRs to follow
	.TEXT	"fig-FORTH "
	.BYTE	FIGREL+30H,ADOT,FIGREV+30H,USRVER
	.WORD	FORTH
	.WORD	DEFIN
	.WORD	QUIT
;
WRM:	LD	BC,WRM1
	JNEXT
WRM1:	.WORD	WARM
;
	.BYTE	84H		;WARM
	.TEXT	"WAR"
	.BYTE	'M'+$80
	.WORD	ABORT-8
WARM:	.WORD	DOCOL
	.WORD	MTBUF
	.WORD	ABORT
;
CLD:	LD	HL,(BDOSS+1)	;/
	LD	L,0		;/ (HL)<--FBASE
	LD	(LIMIT+2),HL	;/ set LIMIT
	LD	DE,BUFSIZ	;/ (DE)<--total disc buffer size
	OR	A		;/ clr carry
	SBC	HL,DE		;/ (HL)<--addr. of 1st disc buffer
	LD	(FIRST+2),HL	;/ set FIRST
	LD	(USE+2),HL	;/ set USE
	LD	(PREV+2),HL	;/ set PREV
	LD	(BUF1),HL	;/
	LD	DE,US		;/ (DE)<--user variable space
	SBC	HL,DE		;/ (HL)<--INITR0
	LD	(UPINIT),HL	;/
	LD	(R0INIT),HL	;/
	LD	(UP),HL		;/
	LD	(RPP),HL	;/
	LD	DE,RTS		;/ (DE)<--return stack & terminal buffer space
	SBC	HL,DE		;/ (HL)<--INITS0
	LD	(S0INIT),HL	;/
	LD	(TIBINI),HL	;/
	LD	SP,HL		;/
	LD	BC,CLD1
	LD	IX,NEXT		; POINTER TO NEXT
	LD	IY,HPUSH	; POINTER TO HPUSH
	JNEXT
;
CLD1:	.WORD	COLD
;
	.BYTE	84H		;COLD
	.TEXT	"COL"
	.BYTE	'D'+$80
	.WORD	WARM-7
COLD:	.WORD	DOCOL
	.WORD	MTBUF
	.WORD	ONE,RECADR	;AvdH
	.WORD	STORE
	.WORD	LIT,BUF1
	.WORD	AT		;/
	.WORD	USE,STORE
	.WORD	LIT,BUF1
	.WORD	AT		;/
	.WORD	PREV,STORE
	.WORD	DRZER
	.WORD	ZERO		;/
	.WORD	LIT,EPRINT
	.WORD	CSTOR		;/
;
	.WORD	LIT
	.WORD	ORIG+12H
	.WORD	LIT
	.WORD	UP
	.WORD	AT
	.WORD	LIT
	.WORD	6
	.WORD	PLUS
	.WORD	LIT
	.WORD	10H
	.WORD	CMOVE
	.WORD	LIT
	.WORD	ORIG+0CH
	.WORD	AT
	.WORD	LIT
	.WORD	FORTH+6
	.WORD	STORE
	.WORD	FCB		;/A
	.WORD	LIT,OPNFIL	;/A open mass storage
	.WORD	BDOS		;/A
	.WORD	LIT,0FFH	;/A
	.WORD	EQUAL		;/A file present?
	.WORD	ZBRAN,CLD2-$-2	;DT /A
	.WORD	ZERO		;/A
	.WORD	WARN,STORE	;/A
	.WORD	CR,PDOTQ	;/A
	.BYTE	7		;/A
	.TEXT	"No file"	;/A
CLD2:	.WORD	ABORT
;
	.BYTE	84H		;S->D
	.TEXT	"S->"
	.BYTE	'D'+$80
	.WORD	COLD-7
STOD:	.WORD	$+2
	POP	DE
	LD	HL,0
	BIT	7,D		;/ # NEGATIVE?
	JR	Z,STOD1		;  NO
	DEC	HL		;  YES, EXTEND SIGN
STOD1:	JP	DPUSH		;  ( n1--d1L d1H)
;
	.BYTE	82H		;+-
	.BYTE	'+'
	.BYTE	'-'+$80
	.WORD	STOD-7
PM:	.WORD	DOCOL
	.WORD	ZLESS
	.WORD	ZBRAN		;IF
	.WORD	PM1-$
	.WORD	MINUS		;ENDIF
PM1:	.WORD	SEMIS
;
	.BYTE	83H		;D+-
	.TEXT	"D+"
	.BYTE	'-'+$80
	.WORD	PM-5
DPM:	.WORD	DOCOL
	.WORD	ZLESS
	.WORD	ZBRAN		;IF
	.WORD	DPM1-$
	.WORD	DMINU		;ENDIF
DPM1:	.WORD	SEMIS
;
	.BYTE	83H		;ABS
	.TEXT	"AB"
	.BYTE	'S'+$80
	.WORD	DPM-6
ABS:	.WORD	DOCOL
	.WORD	DUP
	.WORD	PM
	.WORD	SEMIS
;
	.BYTE	84H		;DABS
	.TEXT	"DAB"
	.BYTE	'S'+$80
	.WORD	ABS-6
DABS:	.WORD	DOCOL
	.WORD	DUP
	.WORD	DPM
	.WORD	SEMIS
;
	.BYTE	83H		;MIN
	.TEXT	"MI"
	.BYTE	'N'+$80
	.WORD	DABS-7
MIN:	.WORD	DOCOL,TDUP
	.WORD	GREAT
	.WORD	ZBRAN		;IF
	.WORD	MIN1-$
	.WORD	SWAP		;ENDIF
MIN1:	.WORD	DROP
	.WORD	SEMIS
;
	.BYTE	83H		;MAX
	.TEXT	"MA"
	.BYTE	'X'+$80
	.WORD	MIN-6
MAX:	.WORD	DOCOL
	.WORD	TDUP
	.WORD	LESS
	.WORD	ZBRAN		;IF
	.WORD	MAX1-$
	.WORD	SWAP		;ENDIF
MAX1:	.WORD	DROP
	.WORD	SEMIS
;
	.BYTE	82H		;M*
	.BYTE	'M'
	.BYTE	'*'+$80
	.WORD	MAX-6
MSTAR:	.WORD	DOCOL,TDUP
	.WORD	XORR
	.WORD	TOR
	.WORD	ABS
	.WORD	SWAP
	.WORD	ABS
	.WORD	USTAR
	.WORD	FROMR
	.WORD	DPM
	.WORD	SEMIS
;
	.BYTE	82H		;M/
	.BYTE	'M'
	.BYTE	'/'+$80
	.WORD	MSTAR-5
MSLAS:	.WORD	DOCOL
	.WORD	OVER
	.WORD	TOR
	.WORD	TOR
	.WORD	DABS
	.WORD	RR
	.WORD	ABS
	.WORD	USLAS
	.WORD	FROMR
	.WORD	RR
	.WORD	XORR
	.WORD	PM
	.WORD	SWAP
	.WORD	FROMR
	.WORD	PM
	.WORD	SWAP
	.WORD	SEMIS
;
	.BYTE	81H		;  *
	.BYTE	'*'+$80
	.WORD	MSLAS-5
STAR:	.WORD	$+2
	EXX			;/ SAVE IP
	POP	HL
	POP	DE
	LD	A,L		;/
	LD	C,H		;/
	LD	B,10H		;/
	LD	HL,0		;/
STAR1:	SRL	C		;/
	RRA			;/ SRL CA  (MPCATOR)
	JR	NC,STAR2	;/ LSB (CA)=0?
	ADD	HL,DE		;/ NO, ADD MPCANT TO HL
STAR2:	SLA	E		;/
	RL	D		;/ SLA DE  (MPCANT 2 *)
	DJNZ	STAR1		;/ DO ALL 16 BITS
	PUSH	HL		;/ (S1)<--PRODUCT
	EXX			;/ RESTORE IP
	JNEXT
;
	.BYTE	84H		;  /MOD
	.TEXT	"/MO"
	.BYTE	'D'+$80
	.WORD	STAR-4
SLMOD:	.WORD	$+2
	POP	DE		;/ DIVISOR
	POP	HL		;/ DIVIDEND
	PUSH	BC		;/ SAVE IP
	XOR	A		;/ RESET NEGATE FLAG
	EX	AF,AF'		;/ ALT SET
	LD	A,D		;/
	OR	E		;/ DIV BY 0?
	JR	NZ,SLMOD1	;/
	LD	HL,-1		;/ YES
	LD	D,H		;/
	LD	E,L		;/ QUOT & REM <-- -1
	JR	SLMOD7		;/ EXIT
SLMOD1:	BIT	7,D		;/ DIVISOR NEGATIVE?
	JR	Z,SLMOD2	;/
	LD	A,E		;/ YES
	CPL			;/
	LD	E,A		;/
	LD	A,D		;/
	CPL			;/
	LD	D,A		;/
	INC	DE		;/ (DE)<--(DE)'s 2's COMPLEMENT
	EX	AF,AF'		;/ STD SET
	SCF			;/ SET NEGATE FLAG
	EX	AF,AF'		;/ ALT SET
SLMOD2:	BIT	7,H		;/ DIVIDEND NEGATIVE?
	JR	Z,SLMOD3	;/
	LD	A,L		;/ YES
	CPL			;/
	LD	L,A		;/
	LD	A,H		;/
	CPL			;/
	LD	H,A		;/
	INC	HL		;/ (HL)<--(HL)'s 2's COMPLEMENT
	EX	AF,AF'		;/ STD SET
	CCF			;/ NEGATE FLAG
	INC	A		;/ DIVIDEND SIGN FLAG
	EX	AF,AF'		;/ ALT SET
SLMOD3:	LD	A,L		;/
	LD	C,H		;/ (CA)<--DIVIDEND
	LD	HL,0		;/ PRIME REMAINDER
	LD	B,10H		;/ LOOP COUNTER
SLMOD4:	RLA			;/
	RL	C		;/ RL CA
	ADC	HL,HL		;/ (HL)<--(HL) 2 * CARRY +
	SBC	HL,DE		;/ UNDERFLOW?
	JR	NC,SLMOD5	;/ NO
	ADD	HL,DE		;/ YES, RESTORE REMAINDER
SLMOD5:	CCF			;/
	DJNZ	SLMOD4		;/ DO ALL 16 BITS
	RLA			;/
	RL	C		;/ RL CA
	LD	E,A		;/
	LD	D,C		;/ (DE)<--QUOTIENT
	EX	AF,AF'		;/ STD SET
	JR	Z,SLMOD6	;/ DIVIDEND POSITIVE
	LD	A,L		;/
	CPL			;/
	LD	L,A		;/
	LD	A,H		;/
	CPL			;/
	LD	H,A		;/
	INC	HL		;/ REM GETS DIVIDEND'S SIGN
SLMOD6:	JR	NC,SLMOD7	;/ QUOTIENT POSITIVE
	LD	A,E		;/
	CPL			;/
	LD	E,A		;/
	LD	A,D		;/
	CPL			;/
	LD	D,A		;/
	INC	DE		;/ NEGATIVE QUOTIENT
SLMOD7:	POP	BC		;/ RESTORE IP
	EX	DE,HL		;/ (S2)<--REMAINDER
	JP	DPUSH		;/ (S1)<--QUOTIENT
;
	.BYTE	81H		; /
	.BYTE	'/'+$80
	.WORD	SLMOD-7
SLASH:	.WORD	$+2
	POP	DE		;/ DIVISOR
	POP	HL		;/ DIVIDEND
	PUSH	BC		;/ SAVE IP
	XOR	A		;/ RESET NEG. FLAG
	EX	AF,AF'		;/ ALT SET
	LD	A,D		;/
	OR	E		;/ DIV BY 0?
	JR	NZ,SLASH1	;/
	LD	HL,-1		;/ YES, SET QUOTIENT TO -1
	JR	SLASH6		;/ EXIT
SLASH1:	BIT	7,D		;/ DIVISOR NEGATIVE?
	JR	Z,SLASH2	;/
	LD	A,E		;/ YES
	CPL			;/
	LD	E,A		;/
	LD	A,D		;/
	CPL			;/
	LD	D,A		;/
	INC	DE		;/ (DE)<--(DE)'s 2's COMPLEMENT
	EX	AF,AF'		;/ STD SET
	SCF			;/ SET NEG. FLAG
	EX	AF,AF'		;/ ALT SET
SLASH2:	BIT	7,H		;/ DIVIDEND NEGATIVE?
	JR	Z,SLASH3	;/
	LD	A,L		;/ YES
	CPL			;/
	LD	L,A		;/
	LD	A,H		;/
	CPL			;/
	LD	H,A		;/
	INC	HL		;/ (HL)<--(HL)'s 2's COMPLEMENT
	EX	AF,AF'		;/ STD SET
	CCF			;/ NEG. FLAG
	EX	AF,AF'		;/ ALT SET
SLASH3:	LD	A,L		;/
	LD	C,H		;/ (CA)<--DIVIDEND
	LD	HL,0		;/
	LD	B,10H		;/ LOOP COUNTER
SLASH4:	RLA			;/
	RL	C		;/ RL CA
	ADC	HL,HL		;/ (HL)<--(HL) 2 * CARRY +
	SBC	HL,DE		;/ UNDERFLOW?
	JR	NC,SLASH5	;/ NO
	ADD	HL,DE		;/ YES, RESTORE REMAINDER
SLASH5:	CCF			;/
	DJNZ	SLASH4		;/ DO ALL 16 BITS
	RLA			;/
	RL	C		;/ RL CA
	LD	L,A		;/
	LD	H,C		;/ (HL)<--QUOTIENT
	EX	AF,AF'		;/ STD SET
	JR	NC,SLASH6	;/ POSITIVE QUOTIENT
	LD	A,L		;/
	CPL			;/
	LD	L,A		;/
	LD	A,H		;/
	CPL			;/
	LD	H,A		;/
	INC	HL		;/ NEGATIVE QUOTIENT
SLASH6:	POP	BC		;/ RESTORE IP
	JHPUSH
;
	.BYTE	83H		; MOD
	.TEXT	"MO"
	.BYTE	'D'+$80
	.WORD	SLASH-4
MODD:	.WORD	DOCOL
	.WORD	SLMOD
	.WORD	DROP
	.WORD	SEMIS
;
	.BYTE	85H		; */MOD
	.TEXT	"*/MO"
	.BYTE	'D'+$80
	.WORD	MODD-6
SSMOD:	.WORD	DOCOL
	.WORD	TOR
	.WORD	MSTAR
	.WORD	FROMR
	.WORD	MSLAS
	.WORD	SEMIS
;
	.BYTE	82H		; */
	.BYTE	'*'
	.BYTE	'/'+$80
	.WORD	SSMOD-8
SSLA:	.WORD	DOCOL
	.WORD	SSMOD
	.WORD	SWAP
	.WORD	DROP
	.WORD	SEMIS
;
	.BYTE	85H		; M/MOD
	.TEXT	"M/MO"
	.BYTE	'D'+$80
	.WORD	SSLA-5
MSMOD:	.WORD	DOCOL
	.WORD	TOR
	.WORD	ZERO
	.WORD	RR
	.WORD	USLAS
	.WORD	FROMR
	.WORD	SWAP
	.WORD	TOR
	.WORD	USLAS
	.WORD	FROMR
	.WORD	SEMIS
;
;	Block moved down 2 pages
;
	.BYTE	86H		; (LINE)
	.TEXT	"(LINE"
	.BYTE	')'+$80
	.WORD	MSMOD-8
PLINE:	.WORD	DOCOL
	.WORD	TOR
	.WORD	LIT
	.WORD	40H
	.WORD	BBUF
	.WORD	SSMOD
	.WORD	FROMR
	.WORD	BSCR
	.WORD	STAR
	.WORD	PLUS
	.WORD	BLOCK
	.WORD	PLUS
	.WORD	LIT
	.WORD	40H
	.WORD	SEMIS
;
	.BYTE	85H		; .LINE
	.TEXT	".LIN"
	.BYTE	'E'+$80
	.WORD	PLINE-9
DLINE:	.WORD	DOCOL
	.WORD	PLINE
	.WORD	DTRAI
	.WORD	TYPE
	.WORD	SEMIS
;
	.BYTE	87H		;MESSAGE
	.TEXT	"MESSAG"
	.BYTE	'E'+$80
	.WORD	DLINE-8
MESS:	.WORD	DOCOL
	.WORD	WARN
	.WORD	AT
	.WORD	ZBRAN		;IF
	.WORD	MESS1-$
	.WORD	DDUP
	.WORD	ZBRAN		;IF
	.WORD	MESS2-$
	.WORD	LIT
	.WORD	4		;1st MESSAGE SCREEN
	.WORD	OFSET
	.WORD	AT
	.WORD	BSCR
	.WORD	SLASH
	.WORD	SUBB
	.WORD	DLINE
	.WORD	SPACE		;ENDIF
MESS2:	.WORD	BRAN		;ELSE
	.WORD	MESS3-$
MESS1:	.WORD	PDOTQ
	.BYTE	6
	.TEXT	"MSG # "
	.WORD	DOT		;ENDIF
MESS3:	.WORD	SEMIS
;
	.BYTE	82H		;P@
	.BYTE	'P'
	.BYTE	'@'+$80
	.WORD	MESS-0AH
PTAT:	.WORD	$+2
	EXX			;d SAVE REGISTERS
	POP	BC		;d (BC)<--PORT#
	IN	L,(C)		;d (L)<--DATA BYTE
	LD	H,0
	PUSH	HL
	EXX			;d RESTORE REGISTERS
	JNEXT
;
	.BYTE	82H		;P!
	.BYTE	'P'
	.BYTE	'!' + $80
	.WORD	PTAT-5
PTSTO:	.WORD	$+2
	EXX			;d SAVE REGISTERS
	POP	BC		;d (C)<--PORT#
	POP	HL		;d (L)<--DATA BYTE
	OUT	(C),L
	EXX			;d RESTORE REGISTERS
	JNEXT
;
	.EJECT
#INCLUDE DISCIO.FTH
	.EJECT
#INCLUDE CONPRTIO.FTH
	.EJECT
;
	.BYTE	0C1H		; ' (tick)
	.BYTE	0A7H
	.WORD	ARROW-6
TICK:	.WORD	DOCOL
	.WORD	DFIND
	.WORD	ZEQU
	.WORD	ZERO
	.WORD	QERR
	.WORD	DROP
	.WORD	LITER
	.WORD	SEMIS
;
	.BYTE	86H		;FORGET
	.TEXT	"FORGE"
	.BYTE	'T'+$80
	.WORD	TICK-4
FORG:	.WORD	DOCOL
	.WORD	CURR
	.WORD	AT
	.WORD	CONT
	.WORD	AT
	.WORD	SUBB
	.WORD	LIT
	.WORD	18H
	.WORD	QERR
	.WORD	TICK
	.WORD	DUP
	.WORD	FENCE
	.WORD	AT
	.WORD	ULESS		;/ FORGET >8000h nw o.k.
	.WORD	LIT
	.WORD	15H
	.WORD	QERR
	.WORD	DUP
	.WORD	NFA
	.WORD	DP
	.WORD	STORE
	.WORD	LFA
	.WORD	AT
	.WORD	CONT
	.WORD	AT
	.WORD	STORE
	.WORD	SEMIS
;
	.BYTE	84H		;BACK
	.TEXT	"BAC"
	.BYTE	'K'+$80
	.WORD	FORG-9
BACK:	.WORD	DOCOL
	.WORD	HERE
	.WORD	SUBB
	.WORD	COMMA
	.WORD	SEMIS
;
	.BYTE	0C5H		;BEGIN
	.TEXT	"BEGI"
	.BYTE	'N'+$80
	.WORD	BACK-7
BEGIN:	.WORD	DOCOL
	.WORD	QCOMP
	.WORD	HERE
	.WORD	ONE
	.WORD	SEMIS
;
	.BYTE	0C5H		;ENDIF
	.TEXT	"ENDI"
	.BYTE	'F'+$80
	.WORD	BEGIN-8
ENDIFF:	.WORD	DOCOL
	.WORD	QCOMP
	.WORD	TWO
	.WORD	QPAIR
	.WORD	HERE
	.WORD	OVER
	.WORD	SUBB
	.WORD	SWAP
	.WORD	STORE
	.WORD	SEMIS
;
	.BYTE	0C4H		;THEN
	.TEXT	"THE"
	.BYTE	'N'+$80
	.WORD	ENDIFF-8
THEN:	.WORD	DOCOL
	.WORD	ENDIFF
	.WORD	SEMIS
;
	.BYTE	0C2H		;DO
	.BYTE	'D'
	.BYTE	'O'+$80
	.WORD	THEN-7
DO:	.WORD	DOCOL
	.WORD	COMP
	.WORD	XDO
	.WORD	HERE
	.WORD	THREE
	.WORD	SEMIS
;
	.BYTE	0C4H		;LOOP
	.TEXT	"LOO"
	.BYTE	'P'+$80
	.WORD	DO-5
LOOP:	.WORD	DOCOL
	.WORD	THREE
	.WORD	QPAIR
	.WORD	COMP
	.WORD	XLOOP
	.WORD	BACK
	.WORD	SEMIS
;
	.BYTE	0C5H		;+LOOP
	.TEXT	"+LOO"
	.BYTE	'P'+$80
	.WORD	LOOP-7
PLOOP:	.WORD	DOCOL
	.WORD	THREE
	.WORD	QPAIR
	.WORD	COMP
	.WORD	XPLOO
	.WORD	BACK
	.WORD	SEMIS
;
	.BYTE	0C5H		;UNTIL
	.TEXT	"UNTI"
	.BYTE	'L'+$80
	.WORD	PLOOP-8
UNTIL:	.WORD	DOCOL
	.WORD	ONE
	.WORD	QPAIR
	.WORD	COMP
	.WORD	ZBRAN
	.WORD	BACK
	.WORD	SEMIS
;
	.BYTE	0C3H		;END
	.TEXT	"EN"
	.BYTE	'D'+$80
	.WORD	UNTIL-8
ENDD:	.WORD	DOCOL
	.WORD	UNTIL
	.WORD	SEMIS
;
	.BYTE	0C5H		;AGAIN
	.TEXT	"AGAI"
	.BYTE	'N'+$80
	.WORD	ENDD-6
AGAIN:	.WORD	DOCOL
	.WORD	ONE
	.WORD	QPAIR
	.WORD	COMP
	.WORD	BRAN
	.WORD	BACK
	.WORD	SEMIS
;
	.BYTE	0C6H		;REPEAT
	.TEXT	"REPEA"
	.BYTE	'T'+$80
	.WORD	AGAIN-8
REPEA:	.WORD	DOCOL
	.WORD	TOR
	.WORD	TOR
	.WORD	AGAIN
	.WORD	FROMR
	.WORD	FROMR
	.WORD	TWOMIN		;/
	.WORD	ENDIFF
	.WORD	SEMIS
;
	.BYTE	0C2H		;IF
	.BYTE	'I'
	.BYTE	'F'+$80
	.WORD	REPEA-9
IFF:	.WORD	DOCOL
	.WORD	COMP
	.WORD	ZBRAN
	.WORD	HERE
	.WORD	ZERO
	.WORD	COMMA
	.WORD	TWO
	.WORD	SEMIS
;
	.BYTE	0C4H		;ELSE
	.TEXT	"ELS"
	.BYTE	'E'+$80
	.WORD	IFF-5
ELSEE:	.WORD	DOCOL
	.WORD	TWO
	.WORD	QPAIR
	.WORD	COMP
	.WORD	BRAN
	.WORD	HERE
	.WORD	ZERO
	.WORD	COMMA
	.WORD	SWAP
	.WORD	TWO
	.WORD	ENDIFF
	.WORD	TWO
	.WORD	SEMIS
;
	.BYTE	0C5H		;WHILE
	.TEXT	"WHIL"
	.BYTE	'E'+$80
	.WORD	ELSEE-7
WHILE:	.WORD	DOCOL
	.WORD	IFF
	.WORD	TWOP
	.WORD	SEMIS
;
	.BYTE	86H		;SPACES
	.TEXT	"SPACE"
	.BYTE	'S'+$80
	.WORD	WHILE-8
SPACS:	.WORD	DOCOL
	.WORD	ZERO
	.WORD	MAX
	.WORD	DDUP
	.WORD	ZBRAN		;IF
	.WORD	SPAX1-$
	.WORD	ZERO
	.WORD	XDO		;DO
SPAX2:	.WORD	SPACE
	.WORD	XLOOP		;LOOP ENDIF
	.WORD	SPAX2-$
SPAX1:	.WORD	SEMIS
;
	.BYTE	82H		;<#
	.BYTE	'<'
	.BYTE	'#'+$80
	.WORD	SPACS-9
BDIGS:	.WORD	DOCOL
	.WORD	PAD
	.WORD	HLD
	.WORD	STORE
	.WORD	SEMIS
;
	.BYTE	82H		;#>
	.BYTE	'#'
	.BYTE	'>'+$80
	.WORD	BDIGS-5
EDIGS:	.WORD	DOCOL
	.WORD	DROP
	.WORD	DROP
	.WORD	HLD
	.WORD	AT
	.WORD	PAD
	.WORD	OVER
	.WORD	SUBB
	.WORD	SEMIS
;
	.BYTE	84H		;SIGN
	.TEXT	"SIG"
	.BYTE	'N'+$80
	.WORD	EDIGS-5
SIGN:	.WORD	DOCOL
	.WORD	ROT
	.WORD	ZLESS
	.WORD	ZBRAN		;IF
	.WORD	SIGN1-$
	.WORD	LIT
	.WORD	2DH
	.WORD	HOLD		;ENDIF
SIGN1:	.WORD	SEMIS
;
	.BYTE	81H		;#
	.BYTE	'#'+$80
	.WORD	SIGN-7
DIG:	.WORD	DOCOL
	.WORD	BASE
	.WORD	AT
	.WORD	MSMOD
	.WORD	ROT
	.WORD	LIT
	.WORD	9
	.WORD	OVER
	.WORD	LESS
	.WORD	ZBRAN		;IF
	.WORD	DIG1-$
	.WORD	LIT
	.WORD	7
	.WORD	PLUS		;ENDIF
DIG1:	.WORD	LIT
	.WORD	30H
	.WORD	PLUS
	.WORD	HOLD
	.WORD	SEMIS
;
	.BYTE	82H		;#S
	.BYTE	'#'
	.BYTE	'S'+$80
	.WORD	DIG-4
DIGS:	.WORD	DOCOL
DIGS1:	.WORD	DIG		;BEGIN
	.WORD	TDUP		;/
	.WORD	ORR
	.WORD	ZEQU
	.WORD	ZBRAN		;UNTIL
	.WORD	DIGS1-$
	.WORD	SEMIS
;
	.BYTE	83H		;D.R
	.TEXT	"D."
	.BYTE	'R'+$80
	.WORD	DIGS-5
DDOTR:	.WORD	DOCOL
	.WORD	TOR
	.WORD	SWAP
	.WORD	OVER
	.WORD	DABS
	.WORD	BDIGS
	.WORD	DIGS
	.WORD	SIGN
	.WORD	EDIGS
	.WORD	FROMR
	.WORD	OVER
	.WORD	SUBB
	.WORD	SPACS
	.WORD	TYPE
	.WORD	SEMIS
;
	.BYTE	82H		;.R
	.BYTE	'.'
	.BYTE	'R'+$80
	.WORD	DDOTR-6
DOTR:	.WORD	DOCOL
	.WORD	TOR
	.WORD	STOD
	.WORD	FROMR
	.WORD	DDOTR
	.WORD	SEMIS
;
	.BYTE	82H		;D.
	.BYTE	'D'
	.BYTE	'.'+$80
	.WORD	DOTR-5
DDOT:	.WORD	DOCOL
	.WORD	ZERO
	.WORD	DDOTR
	.WORD	SPACE
	.WORD	SEMIS
;
	.BYTE	81H		; .
	.BYTE	'.'+$80
	.WORD	DDOT-5
DOT:	.WORD	DOCOL
	.WORD	STOD
	.WORD	DDOT
	.WORD	SEMIS
;
	.BYTE	81H		;?
	.BYTE	'?'+$80
	.WORD	DOT-4
QUES:	.WORD	DOCOL
	.WORD	AT
	.WORD	DOT
	.WORD	SEMIS
;
	.BYTE	82H		;U.
	.BYTE	'U'
	.BYTE	'.'+$80
	.WORD	QUES-4
UDOT:	.WORD	DOCOL
	.WORD	ZERO
	.WORD	DDOT
	.WORD	SEMIS
;
	.BYTE	85H		;VLIST
	.TEXT	"VLIS"
	.BYTE	'T'+$80
	.WORD	UDOT-5
VLIST:	.WORD	DOCOL
	.WORD	LIT
	.WORD	80H
	.WORD	OUTT
	.WORD	STORE
	.WORD	CONT
	.WORD	AT
	.WORD	AT
VLIS1:	.WORD	OUTT		;BEGIN
	.WORD	AT
	.WORD	CSLL
	.WORD	GREAT
	.WORD	ZBRAN		;IF
	.WORD	VLIS2-$
	.WORD	CR
	.WORD	ZERO
	.WORD	OUTT
	.WORD	STORE		;ENDIF
VLIS2:	.WORD	DUP
	.WORD	IDDOT
	.WORD	SPACE
	.WORD	SPACE
	.WORD	PFA
	.WORD	LFA
	.WORD	AT
	.WORD	DUP
	.WORD	ZEQU
	.WORD	QTERM
	.WORD	ORR
	.WORD	ZBRAN		;UNTIL
	.WORD	VLIS1-$
	.WORD	DROP
	.WORD	SEMIS
;
	.BYTE	83H		;BYE
	.TEXT	"BY"
	.BYTE	'E'+$80
	.WORD	VLIST-8
BYE:	.WORD	DOCOL		;/A
	.WORD	FLUSH		;/A
	.WORD	FCB,LIT		;/E
	.WORD	10H,BDOS	;/E close file
	.WORD	DROP		;/E discard directory code
	.WORD	ZERO,ZERO	;/A
	.WORD	BDOS		;/A return to CP/M
	.WORD	SEMIS		;/A won't get this far, just for pretty
;
	.BYTE	84H		;LIST
	.TEXT	"LIS"
	.BYTE	'T'+$80
	.WORD	BYE-6
LIST:	.WORD	DOCOL,DEC
	.WORD	CR,DUP
	.WORD	SCR,STORE
	.WORD	PDOTQ
	.BYTE	6
	.TEXT	"SCR # "
	.WORD	DOT
	.WORD	LIT,10H
	.WORD	ZERO,XDO
LIST1:	.WORD	CR,IDO
	.WORD	THREE		;/ WAS LIT,3
	.WORD	DOTR,SPACE
	.WORD	IDO,SCR
	.WORD	AT,DLINE
	.WORD	QTERM
	.WORD	ZBRAN,LIST2-$-2	; DT - IF
	.WORD	LEAVE
LIST2:	.WORD	XLOOP,LIST1-$-2	; DT - ENDIF
	.WORD	CR,SEMIS
;
	.BYTE	85H		;INDEX
	.TEXT	"INDE"
	.BYTE	'X'+$80
	.WORD	LIST-7
INDEX:	.WORD	DOCOL
	.WORD	LIT,FF
	.WORD	EMIT,CR
	.WORD	ONEP,SWAP
	.WORD	XDO
INDE1:	.WORD	CR,IDO
	.WORD	THREE		;/ WAS LIT,3
	.WORD	DOTR,SPACE
	.WORD	ZERO,IDO
	.WORD	DLINE,QTERM
	.WORD	ZBRAN,INDE2-$-2	; DT - IF
	.WORD	LEAVE		;ENDIF
INDE2:	.WORD	XLOOP,INDE1-$-2 ; DT
	.WORD	SEMIS
;
	.BYTE	85H		;TRIAD
	.TEXT	"TRIA"
	.BYTE	'D'+$80
	.WORD	INDEX-8
TRIAD:	.WORD	DOCOL
	.WORD	LIT,FF
	.WORD	EMIT
	.WORD	THREE		;/ WAS LIT,3
	.WORD	SLASH
	.WORD	THREE		;/ WAS LIT,3
	.WORD	STAR
	.WORD	THREE		;/ WAS LIT,3
	.WORD	OVER,PLUS
	.WORD	SWAP,XDO
TRIA1:	.WORD	CR,IDO
	.WORD	LIST
	.WORD	QTERM
	.WORD	ZBRAN,TRIA2-$-2	; DT - IF
	.WORD	LEAVE
TRIA2:	.WORD	XLOOP,TRIA1-$-2	; DT - ENDIF
	.WORD	CR
	.WORD	LIT,15
	.WORD	MESS,CR
	.WORD	SEMIS
;
	.BYTE	84H		;.CPU
	.TEXT	".CP"
	.BYTE	'U'+$80
	.WORD	TRIAD-8
DOTCPU:	.WORD	DOCOL
	.WORD	BASE,AT
	.WORD	LIT,36
	.WORD	BASE,STORE
	.WORD	LIT,22H
	.WORD	PORIG,TAT
	.WORD	DDOT
	.WORD	BASE,STORE
	.WORD	SEMIS
;
	.BYTE	84H		;TASK
	.TEXT	"TAS"
	.BYTE	'K'+$80
	.WORD	DOTCPU-7
TASK:	.WORD	DOCOL
	.WORD	SEMIS
;
INITDP:	.FILL	95,0
;
	.END
